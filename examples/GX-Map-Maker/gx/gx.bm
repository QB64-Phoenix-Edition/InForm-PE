' GX - A BASIC Game Engine for QB64
' 2021 boxgaming - https://github.com/boxgaming/gx
'
$IF GXBI = UNDEFINED THEN
    OPTION _EXPLICIT
    '$INCLUDE: './gx.bi'

    SUB GXOnGameEvent (e AS GXEvent)
        SELECT CASE e.event
        END SELECT
    END SUB
$END IF
$IF GXBM = UNDEFINED THEN

    ' System Methods
    ' ----------------------------------------------------------------------------
    SUB GXSleep (stime)
        _DELAY stime
    END SUB

    FUNCTION GXMouseX%
        GXMouseX = _MOUSEX / __gx_scene.scaleX
    END FUNCTION

    FUNCTION GXMouseY%
        GXMouseY = _MOUSEY / __gx_scene.scaleY
    END FUNCTION

    SUB GXHardwareAcceleration (hardwareAcceleration AS INTEGER)
        __gx_hardware_acceleration = hardwareAcceleration
    END SUB

    FUNCTION GXHardwareAcceleration%
        GXHardwareAcceleration = __gx_hardware_acceleration
    END FUNCTION


    ' Sound Methods
    ' ----------------------------------------------------------------------------
    FUNCTION GXSoundLoad& (filename AS STRING)
        $IF MAC THEN
            $IF VERSION < 2.1 THEN
                ' Sound not currently supported for macosx
            $ELSE
                GXSoundLoad = _SndOpen(filename)
            $END IF
        $ELSE
            GXSoundLoad = _SNDOPEN(filename)
        $END IF
    END FUNCTION

    SUB GXSoundPlay (sid AS LONG)
        $IF MAC THEN
            $IF VERSION < 2.1 THEN
                ' Sound not currently supported for macosx
            $ELSE
                If Not GXSoundMuted Then _SndPlay sid
            $END IF
        $ELSE
            IF NOT GXSoundMuted THEN _SNDPLAY sid
        $END IF
    END SUB

    SUB GXSoundRepeat (sid AS LONG)
        $IF MAC THEN
            $IF VERSION < 2.1 THEN
                ' Sound not currently supported for macosx
            $ELSE
                If Not GXSoundMuted Then _SndLoop sid
            $END IF
        $ELSE
            IF NOT GXSoundMuted THEN _SNDLOOP sid
        $END IF
    END SUB

    SUB GXSoundVolume (sid AS LONG, v)
        $IF MAC THEN
            $IF VERSION < 2.1 THEN
                ' Sound not currently supported for macosx
            $ELSE
                _SndVol sid, v / 100
            $END IF
        $ELSE
            _SNDVOL sid, v / 100
        $END IF
    END SUB

    SUB GXSoundPause (sid AS LONG)
        $IF MAC THEN
            $IF VERSION < 2.1 THEN
                ' Sound not currently supported for macosx
            $ELSE
                _SndPause sid
            $END IF
        $ELSE
            _SNDPAUSE sid
        $END IF
    END SUB

    SUB GXSoundStop (sid AS LONG)
        $IF MAC THEN
            $IF VERSION < 2.1 THEN
                ' Sound not currently supported for macosx
            $ELSE
                _SndStop sid
            $END IF
        $ELSE
            _SNDSTOP sid
        $END IF
    END SUB

    SUB GXSoundMuted (muted AS INTEGER)
        __gx_sound_muted = muted
        'TODO: maintain a list of loaded sounds so they can all be muted
    END SUB

    FUNCTION GXSoundMuted%
        GXSoundMuted = __gx_sound_muted
    END FUNCTION

    SUB GXEntityAnimate (eid AS INTEGER, seq AS INTEGER, a AS INTEGER)
        __gx_entities(eid).animate = a
        __gx_entities(eid).spriteSeq = seq
        __gx_entities(eid).prevFrame = -1
    END SUB

    SUB GXEntityAnimateStop (eid AS INTEGER)
        __gx_entities(eid).animate = 0
    END SUB

    SUB GXEntityAnimateMode (eid AS INTEGER, mode AS INTEGER)
        __gx_entities(eid).animateMode = mode
    END SUB

    FUNCTION GXEntityAnimateMode% (eid AS INTEGER)
        GXEntityAnimateMode = __gx_entities(eid).animateMode
    END FUNCTION

    FUNCTION GXScreenEntityCreate% (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER)
        DIM eid AS INTEGER
        eid = GXEntityCreate(imageFilename, ewidth, height, seqFrames)
        __gx_entities(eid).screen = 1
        GXScreenEntityCreate = eid
    END FUNCTION

    FUNCTION GXEntityCreate% (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER)
        DIM newent AS GXEntity
        newent.x = 0
        newent.y = 0
        newent.height = height
        newent.width = ewidth
        IF _FILEEXISTS(imageFilename) THEN
            newent.image = __GX_ImageLoad(imageFilename)
        ELSE
            newent.image = __gx_img_blank
        END IF
        newent.spriteFrame = 1
        newent.spriteSeq = 1
        newent.seqFrames = seqFrames
        __gx_entity_count = __gx_entity_count + 1
        REDIM _PRESERVE __gx_entities(__gx_entity_count) AS GXEntity
        __gx_entities(__gx_entity_count) = newent
        GXEntityCreate = __gx_entity_count
    END FUNCTION

    SUB GXEntityCreate (imageFilename AS STRING, ewidth AS INTEGER, height AS INTEGER, seqFrames AS INTEGER, uid AS STRING)
        DIM eid AS INTEGER
        eid = GXEntityCreate(imageFilename, ewidth, height, seqFrames)
        __GX uid, eid, GXTYPE_ENTITY
    END SUB

    SUB GXEntityVisible (eid AS INTEGER, visible AS INTEGER)
        __gx_entities(eid).hidden = NOT visible
    END SUB

    FUNCTION GXEntityVisible% (eid AS INTEGER)
        GXEntityVisible = NOT __gx_entities(eid).hidden
    END FUNCTION

    SUB __GX_EntityDraw (ent AS GXEntity)
        IF ent.hidden THEN EXIT SUB
        DIM x, y AS LONG
        IF ent.screen = 1 THEN
            x = ent.x
            y = ent.y
        ELSE
            x = ent.x - GXSceneX
            y = ent.y - GXSceneY
        END IF
        GXSpriteDraw ent.image, x, y, ent.spriteSeq, ent.spriteFrame, ent.width, ent.height, __gx_scene.image
        IF GXDebug THEN __GX_DebugEntity ent, x, y
    END SUB

    SUB GXEntityMapLayer (eid AS INTEGER, layer AS INTEGER)
        __gx_entities(eid).mapLayer = layer
    END SUB

    FUNCTION GXEntityMapLayer% (eid AS INTEGER)
        GXEntityMapLayer = __gx_entities(eid).mapLayer
    END FUNCTION


    SUB GXEntityMove (eid AS INTEGER, x AS LONG, y AS LONG)
        __gx_entities(eid).x = __gx_entities(eid).x + x
        __gx_entities(eid).y = __gx_entities(eid).y + y
    END SUB


    SUB GXEntityPos (eid AS INTEGER, x AS LONG, y AS LONG)
        __gx_entities(eid).x = x
        __gx_entities(eid).y = y
    END SUB

    SUB GXEntityVX (eid AS INTEGER, vx AS DOUBLE)
        __gx_entities(eid).vx = vx
    END SUB

    FUNCTION GXEntityVX# (eid AS INTEGER)
        GXEntityVX = __gx_entities(eid).vx
    END FUNCTION

    SUB GXEntityVY (eid AS INTEGER, vy AS DOUBLE)
        __gx_entities(eid).vy = vy
    END SUB

    FUNCTION GXEntityVY# (eid AS INTEGER)
        GXEntityVY = __gx_entities(eid).vy
    END FUNCTION


    FUNCTION GXEntityX# (eid AS INTEGER)
        GXEntityX = __gx_entities(eid).x
    END FUNCTION

    FUNCTION GXEntityY# (eid AS INTEGER)
        GXEntityY = __gx_entities(eid).y
    END FUNCTION

    FUNCTION GXEntityWidth% (eid AS INTEGER)
        GXEntityWidth = __gx_entities(eid).width
    END FUNCTION

    FUNCTION GXEntityHeight% (eid AS INTEGER)
        GXEntityHeight = __gx_entities(eid).height
    END FUNCTION

    SUB GXEntityFrameNext (eid AS INTEGER)
        IF __gx_entities(eid).animateMode = GXANIMATE_SINGLE THEN
            IF __gx_entities(eid).spriteFrame + 1 > __gx_entities(eid).seqFrames THEN
                IF NOT __gx_entities(eid).spriteFrame = __gx_entities(eid).prevFrame THEN
                    ' Fire animation complete event
                    DIM e AS GXEvent
                    e.event = GXEVENT_ANIMATE_COMPLETE
                    e.entity = eid
                    GXOnGameEvent e
                    __gx_entities(eid).prevFrame = __gx_entities(eid).spriteFrame
                END IF
                EXIT SUB
            END IF
        END IF

        __gx_entities(eid).prevFrame = __gx_entities(eid).spriteFrame
        __gx_entities(eid).spriteFrame = __gx_entities(eid).spriteFrame + 1
        IF __gx_entities(eid).spriteFrame > __gx_entities(eid).seqFrames THEN
            __gx_entities(eid).spriteFrame = 1
        END IF
    END SUB

    SUB GXEntityFrameSet (eid AS INTEGER, seq AS INTEGER, frame AS INTEGER)
        __gx_entities(eid).spriteSeq = seq
        __gx_entities(eid).spriteFrame = frame
        __gx_entities(eid).prevFrame = frame - 1
    END SUB

    FUNCTION GXEntityFrame (eid AS INTEGER)
        GXEntityFrame = __gx_entities(eid).spriteFrame
    END FUNCTION

    FUNCTION GXEntitySequence (eid AS INTEGER)
        GXEntitySequence = __gx_entities(eid).spriteSeq
    END FUNCTION

    'SUB GXEntityImageSet (eid AS INTEGER, filename AS STRING)
    '    __gx_entities(eid).image = __GX_ImageLoad(filename)
    'END SUB

    SUB GXEntityType (eid AS INTEGER, etype AS INTEGER)
        __gx_entities(eid).type = etype
    END SUB

    FUNCTION GXEntityType% (eid AS INTEGER)
        GXEntityType = __gx_entities(eid).type
    END FUNCTION


    ' TODO: Replace this implementation with a hash table lookup so we can scale
    '       efficiently when managing very large numbers of entities
    ' ----------------------------------------------------------------------------
    FUNCTION GXEntityUID$ (eid AS INTEGER)
        GXEntityUID = __GX_UID(GXTYPE_ENTITY, eid)
    END FUNCTION

    FUNCTION GXFontUID$ (fid AS INTEGER)
        GXFontUID = __GX_UID(GXTYPE_FONT, fid)
    END FUNCTION

    ' TODO: Expand this concept to lookup any GX object id by its user assigned id
    '       Maybe not "any" GX object... need to decide which ones would be applicable
    FUNCTION GX% (uid AS STRING * 10)
        GX = 0
        DIM i AS INTEGER
        FOR i = 1 TO UBOUND(__gx_objects)
            IF RTRIM$(__gx_objects(i).uid) = uid THEN
                GX = __gx_objects(i).id
                EXIT FUNCTION
            END IF
        NEXT i
    END FUNCTION

    SUB __GX (uid AS STRING * 10, id AS INTEGER, otype AS INTEGER)
        DIM count AS INTEGER
        count = UBOUND(__gx_objects) + 1
        REDIM _PRESERVE __gx_objects(count) AS GXObject
        __gx_objects(count).uid = uid
        __gx_objects(count).id = id
        __gx_objects(count).type = otype
    END SUB

    FUNCTION __GX_UID$ (otype AS INTEGER, id AS INTEGER)
        DIM uid AS STRING
        DIM i AS INTEGER
        FOR i = 1 TO UBOUND(__gx_objects)
            IF __gx_objects(i).type = otype THEN
                IF __gx_objects(i).id = id THEN
                    uid = RTRIM$(__gx_objects(i).uid)
                END IF
            END IF
        NEXT i
        __GX_UID = uid
    END FUNCTION
    ' ----------------------------------------------------------------------------


    SUB GXEntityApplyGravity (eid AS INTEGER, gravity AS INTEGER)
        __gx_entities(eid).applyGravity = gravity
        __gx_entities(eid).jumpstart = GXFrame
    END SUB

    FUNCTION GXEntityApplyGravity% (eid AS INTEGER)
        GXEntityApplyGravity = __gx_entities(eid).applyGravity
    END FUNCTION

    SUB GXEntityCollisionOffset (eid AS INTEGER, left AS INTEGER, top AS INTEGER, right AS INTEGER, bottom AS INTEGER)
        __gx_entities(eid).coLeft = left
        __gx_entities(eid).coTop = top
        __gx_entities(eid).coRight = right
        __gx_entities(eid).coBottom = bottom
    END SUB

    FUNCTION GXEntityCollisionOffsetLeft% (eid AS INTEGER)
        GXEntityCollisionOffsetLeft = __gx_entities(eid).coLeft
    END FUNCTION

    FUNCTION GXEntityCollisionOffsetTop% (eid AS INTEGER)
        GXEntityCollisionOffsetTop = __gx_entities(eid).coTop
    END FUNCTION

    FUNCTION GXEntityCollisionOffsetRight% (eid AS INTEGER)
        GXEntityCollisionOffsetRight = __gx_entities(eid).coRight
    END FUNCTION

    FUNCTION GXEntityCollisionOffsetBottom% (eid AS INTEGER)
        GXEntityCollisionOffsetBottom = __gx_entities(eid).coBottom
    END FUNCTION

    FUNCTION GXDeviceInputTest% (di AS GXDeviceInput)
        DIM dcount AS INTEGER
        dcount = _DEVICES

        IF di.deviceId < 1 OR di.deviceId > dcount THEN
            GXDeviceInputTest = GX_FALSE
            EXIT FUNCTION
        END IF

        DIM result AS INTEGER
        DIM dactive AS INTEGER
        dactive = _DEVICEINPUT(di.deviceId)

        IF di.inputType = GXDEVICE_BUTTON THEN
            $IF WIN THEN
                IF _BUTTON(di.inputId) = di.inputValue THEN
                    result = GX_TRUE
                END IF
            $ELSE
                If di.deviceType = GXDEVICE_KEYBOARD Then
                    result = __GX_DeviceKeyDown(di.inputId)
                Else
                    If _Button(di.inputId) = di.inputValue Then
                        result = GX_TRUE
                    End If
                End If
            $END IF

        ELSEIF di.inputType = GXDEVICE_AXIS THEN
            IF _AXIS(di.inputId) = di.inputValue THEN
                result = GX_TRUE
            END IF
        END IF

        GXDeviceInputTest = result
    END FUNCTION

    $IF LINUX OR MAC THEN
        Function __GX_DeviceKeyDown% (inputId As Integer)
            Dim k As KeyEntry
            k = __gx_keymap(inputId)

            Dim result As Integer
            result = GX_FALSE
            If _KeyDown(k.value) Then
                result = GX_TRUE
            ElseIf k.shift <> 0 Then
                If _KeyDown(k.shift) Then result = GX_TRUE
            End If

            __GX_DeviceKeyDown = result
        End Function
    $END IF

    ' Sets the fullscreen status.
    ' When set to true the scene content will stretch to fill the entire screen.
    ' This value is set to false by default.
    SUB GXFullScreen (fullscreen AS INTEGER)
        IF fullscreen THEN
            _FULLSCREEN _SQUAREPIXELS
        ELSE
            _FULLSCREEN _OFF
        END IF
        __gx_scene.fullscreen = fullscreen
    END SUB

    ' Sets the fullscreen status.
    FUNCTION GXFullScreen%
        GXFullScreen = __gx_scene.fullscreen
    END FUNCTION

    ' Adds a new background image to the current scene.  Multiple background images may be added to the scene.
    ' Background images are displayed in layers based on the order they are added.
    ' One of the following modes must be specified:
    '   GXBG_STRETCH - Stretch the background image to the size of the scene.
    '   GXBG_SCROLL  - Fit the height of the background image to the size of the screen.
    '                  Scroll the horizontal position relative to the position on the map.
    '   GXBG_WRAP    - Continuously wrap the background image as the scene is moved.
    FUNCTION GXBackgroundAdd% (imageFilename AS STRING, mode AS INTEGER)
        __gx_bg_count = __gx_bg_count + 1
        REDIM _PRESERVE __gx_bg(__gx_bg_count) AS GXBackground
        __gx_bg(__gx_bg_count).mode = mode
        __gx_bg(__gx_bg_count).wrapFactor = 1
        __gx_bg(__gx_bg_count).image = __GX_ImageLoad(imageFilename)
        GXBackgroundAdd = __gx_bg_count
    END FUNCTION

    SUB GXBackgroundWrapFactor (gi AS INTEGER, wrapFactor AS DOUBLE)
        __gx_bg(gi).wrapFactor = wrapFactor
    END SUB

    ' Removes all background images from the scene.
    SUB GXBackgroundClear
        __gx_bg_count = 0
        REDIM __gx_bg(0) AS GXBackground
    END SUB

    SUB __GX_BackgroundDraw (bi AS INTEGER)
        DIM factor, xfactor
        DIM w AS LONG, h AS LONG, x AS LONG, y AS LONG

        IF __gx_bg(bi).mode = GXBG_STRETCH THEN
            _PUTIMAGE , __gx_bg(bi).image, __gx_scene.image

        ELSEIF __gx_bg(bi).mode = GXBG_SCROLL THEN
            factor = GXSceneWidth / GXSceneHeight
            h = _HEIGHT(__gx_bg(bi).image)
            w = h * factor
            xfactor = GXSceneX / (GXMapColumns * GXTilesetWidth)
            x = xfactor * (_WIDTH(__gx_bg(bi).image) - w)
            _PUTIMAGE , __gx_bg(bi).image, __gx_scene.image, (x, 0)-(x + w, h)

        ELSEIF __gx_bg(bi).mode = GXBG_WRAP THEN
            __GX_BackgroundDrawWrap (bi)
        END IF
    END SUB

    SUB __GX_BackgroundDrawWrap (bi AS INTEGER)
        DIM img AS LONG
        DIM AS LONG x, y, x2, y2, xx, yy, w, h
        DIM wrapFactor AS DOUBLE

        img = __gx_bg(bi).image
        wrapFactor = __gx_bg(bi).wrapFactor

        x = (GXSceneX * wrapFactor) MOD _WIDTH(img)
        y = (GXSceneY * wrapFactor) MOD _HEIGHT(img)
        IF x < 0 THEN x = _WIDTH(img) + x
        IF y < 0 THEN y = _HEIGHT(img) + y
        x2 = GXSceneWidth + x
        y2 = GXSceneHeight + y

        _PUTIMAGE (0, 0), img, __gx_scene.image, (x, y)-(x2, y2)

        IF x2 > _WIDTH(img) THEN
            w = x2 - _WIDTH(img)
            xx = GXSceneWidth - w

            _PUTIMAGE (xx, 0), img, __gx_scene.image, (0, y)-(w, y2)
        END IF

        IF y2 > _HEIGHT(img) THEN
            h = y2 - _HEIGHT(img)
            yy = GXSceneHeight - h

            _PUTIMAGE (0, yy), img, __gx_scene.image, (x, 0)-(x2, h)
        END IF

        IF x2 > _WIDTH(img) AND y2 > _HEIGHT(img) THEN
            w = x2 - _WIDTH(img)
            h = y2 - _HEIGHT(img)
            xx = GXSceneWidth - w
            yy = GXSceneHeight - h

            _PUTIMAGE (xx, yy), img, __gx_scene.image, (0, 0)-(w, h)
        END IF

    END SUB

    ' Gets the embedded flag for the scene.
    SUB GXSceneEmbedded (embedded AS INTEGER)
        __gx_scene.embedded = embedded
    END SUB

    ' Sets the embedded flag for the scene.
    ' The embedded flag should be set to true when the game loop is being
    ' managed manually or by an external framework (e.g. QB64 Inform).
    ' This value is set to false by default.
    FUNCTION GXSceneEmbedded%
        GXSceneEmbedded = __gx_scene.embedded
    END FUNCTION

    FUNCTION __GX_HardwareImage& (iwidth AS INTEGER, iheight AS INTEGER)
        DIM newImage AS LONG
        newImage = _NEWIMAGE(iwidth, iheight, 32)
        'If Not GXSceneEmbedded Then
        IF GXHardwareAcceleration THEN
            DIM hwImage AS LONG
            hwImage = _COPYIMAGE(newImage, 33)
            _FREEIMAGE newImage
            __GX_HardwareImage = hwImage
        ELSE
            __GX_HardwareImage = newImage
        END IF
    END FUNCTION

    ' Creates a new scene with the specified pixel width and height.
    SUB GXSceneCreate (swidth AS INTEGER, sheight AS INTEGER)
        __gx_scene.width = swidth
        __gx_scene.height = sheight

        IF NOT GXSceneEmbedded THEN
            'If GXHardwareAcceleration Then
            DIM oldimg AS LONG
            oldimg = _SCREENIMAGE
            SCREEN _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
            'Dim hwImage As Long
            'hwImage = __GX_HardwareImage(GXSceneWidth, GXSceneHeight)
            'Screen hwImage
            _FREEIMAGE oldimg
        END IF

        IF __gx_scene.image THEN _FREEIMAGE __gx_scene.image
        'If Not GXSceneEmbedded Then
        IF GXHardwareAcceleration THEN
            __gx_scene.image = __GX_HardwareImage(GXSceneWidth, GXSceneHeight)
        ELSE
            __gx_scene.image = _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
        END IF

        'If Not GXSceneEmbedded Then
        IF GXHardwareAcceleration THEN
            IF NOT __gx_img_blank THEN __gx_img_blank = __GX_HardwareImage(1, 1)
        ELSE
            IF NOT __gx_img_blank THEN __gx_img_blank = _NEWIMAGE(1, 1, 32)
        END IF

        __gx_scene.scaleX = 1
        __gx_scene.scaleY = 1

        __GX_CustomEvent GXEVENT_INIT

    END SUB

    ' Scale the scene to the specified window size.
    SUB GXSceneWindowSize (swidth AS INTEGER, sheight AS INTEGER)
        DIM oldimg AS LONG
        oldimg = _SCREENIMAGE
        SCREEN _NEWIMAGE(swidth, sheight, 32)
        'SCREEN __GX_HardwareImage(swidth, sheight)
        _FREEIMAGE oldimg
        __gx_scene.scaleX = swidth / GXSceneWidth
        __gx_scene.scaleY = sheight / GXSceneHeight
    END SUB

    ' Scale the scene by the specified scale factor.
    SUB GXSceneScale (scale AS SINGLE)
        __gx_scene.scaleX = scale
        __gx_scene.scaleY = scale
        IF NOT GXSceneEmbedded THEN
            DIM oldimg AS LONG
            oldimg = _SCREENIMAGE
            SCREEN _NEWIMAGE(GXSceneWidth * __gx_scene.scaleX, GXSceneHeight * __gx_scene.scaleY, 32)
            'SCREEN __GX_HardwareImage(gx_scene.width * gx_scene.scaleX, gx_scene.height * gx_scene.scaleY)
            _FREEIMAGE oldimg
        END IF
    END SUB

    ' Resize the scene with the specified pixel width and height.
    SUB GXSceneResize (swidth AS INTEGER, sheight AS INTEGER)
        __gx_scene.width = swidth
        __gx_scene.height = sheight

        IF __gx_scene.image THEN _FREEIMAGE (__gx_scene.image)
        __gx_scene.image = _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
        'gx_scene.image = __GX_HardwareImage(gx_scene.width, gx_scene.height)

        IF NOT GXSceneEmbedded THEN
            DIM oldimg AS LONG
            oldimg = _SCREENIMAGE
            SCREEN _NEWIMAGE(GXSceneWidth, GXSceneHeight, 32)
            'SCREEN __GX_HardwareImage(gx_scene.width, gx_scene.height)
            _FREEIMAGE oldimg
        END IF
        __GX_UpdateSceneSize
    END SUB

    SUB GXSceneDestroy
        _DELAY .1
        GXSceneStop
        _FREEIMAGE __gx_scene.image
        _FREEIMAGE __gx_img_blank
        __gx_scene.image = 0
        __gx_img_blank = 0
        DIM i AS INTEGER
        FOR i = 0 TO __gx_image_count - 1
            _FREEIMAGE __gx_images(i).id
        NEXT i
        __gx_image_count = 0
        REDIM __gx_images(0) AS GXImage
    END SUB

    SUB __GX_CustomEvent (eventType AS INTEGER)
        DIM e AS GXEvent
        e.event = eventType
        GXOnGameEvent e
    END SUB

    'Sub GXCustomDraw (eventType As Integer, enabled As Integer)
    '    __gx_draw_events(eventType) = enabled
    'End Sub

    'Function GXCustomDraw (eventType As Integer)
    '    GXCustomDraw = __gx_draw_events(eventType)
    'End Function

    SUB __GX_CustomDrawEvent (eventType AS INTEGER)
        IF NOT GXHardwareAcceleration THEN _DEST __gx_scene.image
        __GX_CustomEvent eventType
        IF NOT GXHardwareAcceleration THEN _DEST 0

        'If GXSceneEmbedded Then
        '    _Dest __gx_scene.image
        '    __GX_CustomEvent eventType
        '    If GXDebug And eventType = GXEVENT_DRAWMAP Then __GX_DebugMapTile
        '    _Dest 0
        'Else
        '    If GXCustomDraw(eventType) Or (GXDebug And GXEVENT_DRAWMAP) Or (GXDebug And GXEVENT_DRAWSCREEN) Then
        '        If __gx_scene.customImage = 0 Then __gx_scene.customImage = _NewImage(GXSceneWidth, GXSceneHeight, 32)
        '        If __gx_img_blank_s = 0 Then __gx_img_blank_s = _NewImage(1, 1, 32)
        '        _DontBlend __gx_scene.customImage
        '        _PutImage , __gx_img_blank_s, __gx_scene.customImage
        '        _Blend __gx_scene.customImage
        '        _Dest __gx_scene.customImage
        '    End If
        '    __GX_CustomEvent eventType
        '    If GXCustomDraw(eventType) Or (GXDebug And GXEVENT_DRAWMAP) Or (GXDebug And GXEVENT_DRAWSCREEN) Then
        '        If GXDebug Then
        '            If eventType = GXEVENT_DRAWMAP Then __GX_DebugMapTile
        '            If eventType = GXEVENT_DRAWSCREEN Then __GX_DebugEntities
        '        End If
        '        _Dest 0
        '        Dim tmpImage As Long
        '        tmpImage = _CopyImage(__gx_scene.customImage, 33)
        '        _PutImage , tmpImage, __gx_scene.image
        '        _FreeImage tmpImage
        '    End If
        'End If


    END SUB

    'Sub __GX_DebugEntities
    '    Dim e As GXEntity
    '    Dim ei As Integer
    '    For ei = 1 To __gx_entity_count
    '        e = __gx_entities(ei)
    '        If e.screen = 0 Then
    '            If __GX_RectCollide(e.x, e.y, e.width, e.height, GXSceneX, GXSceneY, GXSceneWidth, GXSceneHeight) Then
    '                Dim x, y As Long
    '                If e.screen = 1 Then
    '                    x = e.x
    '                    y = e.y
    '                Else
    '                    x = e.x - GXSceneX
    '                    y = e.y - GXSceneY
    '                End If
    '                __GX_DebugEntity e, x, y
    '            End If
    '        End If
    '    Next ei
    'End Sub


    ' Returns the current frame rate (expressed in frames-per-second or FPS).
    SUB GXFrameRate (frameRate AS INTEGER)
        __gx_framerate = frameRate
    END SUB

    ' Sets current frame rate (expressed in frames-per-second or FPS).
    ' The default value for the frame rate is 60
    FUNCTION GXFrameRate%
        GXFrameRate = __gx_framerate
    END FUNCTION

    ' Returns the current frame.
    ' This is a frame counter that starts when GXSceneStart is called.
    ' It is initially set to zero and is incremented on each frame.
    FUNCTION GXFrame~&
        GXFrame = __gx_scene.frame
    END FUNCTION

    ' Draw the scene.
    ' This method is called automatically when GX is managing the event/game loop.
    ' Call this method for each page draw event when the event/game loop is being
    ' handled externally.
    SUB GXSceneDraw
        IF __gx_map_loading THEN EXIT SUB
        DIM ei AS INTEGER
        DIM ei2 AS INTEGER
        DIM frame AS INTEGER
        frame = __gx_scene.frame MOD GXFrameRate + 1

        ' If the screen has been resized, resize the destination screen image
        IF NOT GXSceneEmbedded THEN
            IF _RESIZE THEN
                '_FREEIMAGE _SOURCE
                'SCREEN _NEWIMAGE(_RESIZEWIDTH, _RESIZEHEIGHT, 32)
                GXSceneWindowSize _RESIZEWIDTH, _RESIZEHEIGHT
            END IF
        END IF

        ' Clear the background
        _DONTBLEND __gx_scene.image
        _PUTIMAGE , __gx_img_blank, __gx_scene.image
        _BLEND __gx_scene.image

        ' Draw background images, if present
        DIM bi AS INTEGER
        FOR bi = 1 TO __gx_bg_count
            __GX_BackgroundDraw bi
        NEXT bi

        'Call out to any custom screen drawing
        __GX_CustomDrawEvent GXEVENT_DRAWBG

        ' Initialize the renderable entities
        REDIM __gx_entities_active(0) AS INTEGER
        DIM ent AS GXEntity
        FOR ei = 1 TO UBOUND(__gx_entities) ' _entities.length; ei++) {
            ent = __gx_entities(ei)
            IF NOT ent.screen THEN ') {
                IF __GX_RectCollide(ent.x, ent.y, ent.width, ent.height, GXSceneX, GXSceneY, GXSceneWidth, GXSceneHeight) THEN
                    DIM ecount AS INTEGER
                    ecount = UBOUND(__gx_entities_active) + 1
                    REDIM _PRESERVE __gx_entities_active(ecount) AS INTEGER
                    __gx_entities_active(ecount) = ei
                END IF
            END IF
        NEXT ei

        ' Draw the map tiles
        GXMapDraw
        IF GXDebug THEN __GX_DebugMapTile

        'Call out to any custom screen drawing
        __GX_CustomDrawEvent GXEVENT_DRAWMAP

        ' Draw the entities
        __GX_DrawEntityLayer 0

        ' Draw the entities
        'Dim e As GXEntity
        'For ei = 1 To __gx_entity_count
        '    e = __gx_entities(ei)
        '    If e.screen = 0 Then
        '        If __GX_RectCollide(e.x, e.y, e.width, e.height, GXSceneX, GXSceneY, GXSceneWidth, GXSceneHeight) Then
        '            'Print ei, e.image
        '            'Dim a: Input a
        '            __GX_EntityDraw e
        '        End If
        '    End If
        '    If e.animate > 0 Then
        '        If frame Mod (GXFrameRate / e.animate) = 0 Then
        '            GXEntityFrameNext ei
        '        End If
        '   End If
        'Next ei

        ' Draw the screen entities which should appear on top of the other game entities
        ' and have a fixed position
        FOR ei2 = 1 TO __gx_entity_count
            IF __gx_entities(ei2).screen = 1 THEN
                __GX_EntityDraw __gx_entities(ei2)
            END IF
        NEXT ei2

        IF GXDebug THEN __GX_DebugMapTile


        'Call out to any custom screen drawing
        __GX_CustomDrawEvent GXEVENT_DRAWSCREEN
        IF GXDebug THEN __GX_DebugFrameRate

        ' Copy the background image to the screen
        __GX_CustomEvent GXEVENT_PAINTBEFORE
        _DONTBLEND
        _PUTIMAGE , __gx_scene.image
        _BLEND
        __GX_CustomEvent GXEVENT_PAINTAFTER
    END SUB

    SUB __GX_DrawEntityLayer (layer AS INTEGER)
        DIM AS INTEGER frame, i, ei
        DIM AS GXEntity e
        frame = __gx_scene.frame MOD GXFrameRate + 1

        FOR i = 1 TO UBOUND(__gx_entities_active)
            ei = __gx_entities_active(i)
            e = __gx_entities(ei)
            IF e.mapLayer = layer THEN
                __GX_EntityDraw e
                IF e.animate > 0 THEN
                    IF frame MOD (GXFrameRate / e.animate) = 0 THEN
                        GXEntityFrameNext ei
                    END IF
                END IF
            END IF
        NEXT i
    END SUB


    ' Moves the scene position by the number of pixels specified by the dx and dy values.
    ' The default position for a scene is (0,0). Negative x and y values are valid.
    ' A non-zero value for dx will move the scene by the number of pixels specified to the right or left.
    ' A non-zero value for dy will move the scene by the number of pixels specified up or down.
    SUB GXSceneMove (dx AS LONG, dy AS LONG)
        __gx_scene.x = GXSceneX + dx
        __gx_scene.y = GXSceneY + dy
    END SUB

    ' Positions the scene at the specified x and y coordinates.
    ' The default position for a scene is (0,0). Negative x and y values are valid.
    SUB GXScenePos (x AS LONG, y AS LONG)
        __gx_scene.x = x
        __gx_scene.y = y
    END SUB

    ' Returns the scene's current y position.
    FUNCTION GXSceneX%
        GXSceneX = __gx_scene.x
    END FUNCTION

    ' Returns the scene's current y position.
    FUNCTION GXSceneY%
        GXSceneY = __gx_scene.y
    END FUNCTION

    ' Returns the scene width.
    FUNCTION GXSceneWidth%
        GXSceneWidth = __gx_scene.width
    END FUNCTION

    ' Returns the scene height.
    FUNCTION GXSceneHeight%
        GXSceneHeight = __gx_scene.height
    END FUNCTION

    ' Returns the number of tile columns that can be displayed within the scene.
    ' This value will be zero unless a tiled map has been created or loaded.
    FUNCTION GXSceneColumns%
        GXSceneColumns = __gx_scene.columns
    END FUNCTION

    ' Returns the number of tile rows that can be displayed within the scene.
    ' This value will be zero unless a tiled map has been created or loaded.
    FUNCTION GXSceneRows%
        GXSceneRows = __gx_scene.rows
    END FUNCTION

    ' Start the game loop.
    ' This method will not return control to the calling program until the
    ' game loop is interrupted with the GXSceneStop method.
    ' Game events will be sent to the GXOnGameEvent method during the game
    ' loop execution.
    SUB GXSceneStart

        __gx_scene.frame = 0
        __gx_scene.active = 1

        'DIM dcount AS INTEGER
        'dcount = _DEVICES
        DO
            _LIMIT GXFrameRate

            ' Update the scene
            GXSceneUpdate

            ' Redraw the scene
            GXSceneDraw
            _DISPLAY

        LOOP WHILE __gx_scene.active
    END SUB

    SUB GXSceneUpdate
        __gx_scene.frame = __gx_scene.frame + 1

        ' Capture mouse events when not embedded
        IF NOT GXSceneEmbedded THEN
            DIM mi AS LONG
            mi = _MOUSEINPUT
        END IF

        ' Call custom game update logic
        __GX_CustomEvent GXEVENT_UPDATE

        ' Check for entity movement and collisions
        ' TODO: filter out non-moving entities
        __GX_SceneMoveEntities

        ' Perform any auto-scene moves
        DIM sx AS LONG, sy AS LONG
            IF __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER OR _
            __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X OR _
            __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_POS OR _
            __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_NEG THEN
            sx = (GXEntityX(__gx_scene.followEntity) + GXEntityWidth(__gx_scene.followEntity) / 2) - GXSceneWidth / 2
            IF (sx < GXSceneX AND __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_POS) OR _
            (sx > GXSceneX AND __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_X_NEG) THEN
                ' don't move the scene
            ELSE
                GXScenePos sx, GXSceneY
            END IF
        END IF
            IF __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER OR _
            __gx_scene.followMode = GXSCENE_FOLLOW_ENTITY_CENTER_Y THEN
            sy = (GXEntityY(__gx_scene.followEntity) + GXEntityHeight(__gx_scene.followEntity) / 2) - GXSceneHeight / 2
            GXScenePos GXSceneX, sy
        END IF

        ' Check the scene move constraints
        IF __gx_scene.constrainMode = GXSCENE_CONSTRAIN_TO_MAP THEN
            DIM mwidth AS INTEGER
            DIM mheight AS INTEGER
            mwidth = GXMapColumns * GXTilesetWidth
            mheight = GXMapRows * GXTilesetHeight
            sx = GXSceneX
            IF sx < 0 THEN
                sx = 0
            ELSEIF sx + GXSceneWidth > mwidth THEN
                sx = mwidth - GXSceneWidth
                IF sx < 0 THEN sx = 0
            END IF

            sy = GXSceneY
            IF sy < 0 THEN
                sy = 0
            ELSEIF sy + GXSceneHeight > mheight THEN
                sy = mheight - GXSceneHeight
                IF sy < 0 THEN sy = 0
            END IF
            GXScenePos sx, sy
        END IF

        IF NOT GXSceneEmbedded THEN
            WHILE _MOUSEINPUT
                ' Flush mouse event buffer
            WEND
        END IF
    END SUB

    ' TODO: revisit "follow" wording.
    SUB GXSceneFollowEntity (eid AS INTEGER, mode AS INTEGER)
        __gx_scene.followEntity = eid
        __gx_scene.followMode = mode
    END SUB

    SUB GXSceneConstrain (mode AS INTEGER)
        __gx_scene.constrainMode = mode
    END SUB

    SUB __GX_SceneMoveEntities
        DIM frameFactor AS DOUBLE
        frameFactor = 1 / GXFrameRate

        'DIM e AS GXEntity
        DIM eid AS INTEGER, ci AS INTEGER
        REDIM centities(0) AS INTEGER
        DIM ecount AS INTEGER
        FOR eid = 1 TO __gx_entity_count
            IF __gx_entities(eid).screen = 0 THEN
                __GX_SceneMoveEntity eid

                ' apply the move vector to the entity's position
                IF __gx_entities(eid).vx THEN
                    __gx_entities(eid).x = __gx_entities(eid).x + __gx_entities(eid).vx * frameFactor
                END IF
                IF __gx_entities(eid).vy THEN
                    __gx_entities(eid).y = __gx_entities(eid).y + __gx_entities(eid).vy * frameFactor
                END IF
            END IF
        NEXT eid
    END SUB


    SUB __GX_SceneMoveEntity (eid AS LONG)
        DIM tpos AS GXPosition
        DIM centity AS INTEGER
        DIM tmove AS INTEGER
        DIM testx AS INTEGER
        DIM testy AS INTEGER

        ' Test upward movement
        IF GXEntityVY(eid) < 0 THEN
            testy = GXEntityVY(eid) / GXFrameRate
            IF testy > -1 THEN testy = -1
            tmove = __GX_EntityTestMove(eid, 0, testy, tpos, centity)
            IF NOT tmove THEN
                IF GXEntityApplyGravity(eid) THEN
                    ' reverse the motion
                    GXEntityVY eid, GXEntityVY(eid) * -.5
                ELSE
                    ' stop the motion
                    GXEntityVY eid, 0
                END IF

                ' don't let the entity pass into the collision entity or tile
                IF centity > 0 THEN
                    GXEntityPos eid, GXEntityX(eid), GXEntityY(centity) - GXEntityCollisionOffsetBottom(centity) + GXEntityHeight(centity) - GXEntityCollisionOffsetTop(eid)
                ELSE
                    GXEntityPos eid, GXEntityX(eid), (tpos.y + 1) * GXTilesetHeight - GXEntityCollisionOffsetTop(eid)
                END IF

            END IF
        END IF

        IF NOT GXEntityApplyGravity(eid) THEN
            ' Test downward movement
            IF GXEntityVY(eid) > 0 THEN
                testy = GXEntityVY(eid) / GXFrameRate
                IF testy < 1 THEN testy = 1
                tmove = __GX_EntityTestMove(eid, 0, testy, tpos, centity)
                IF NOT tmove THEN
                    ' stop the motion
                    GXEntityVY eid, 0

                    ' don't let the entity pass into the collision entity or tile
                    IF centity > 0 THEN
                        GXEntityPos eid, GXEntityX(eid), GXEntityY(centity) + GXEntityCollisionOffsetTop(centity) - GXEntityHeight(eid) + GXEntityCollisionOffsetBottom(eid)
                    END IF
                    IF tpos.y > -1 THEN
                        GXEntityPos eid, GXEntityX(eid), tpos.y * GXTilesetHeight - GXEntityHeight(eid) + GXEntityCollisionOffsetBottom(eid)
                    END IF
                END IF
            END IF

        ELSE

            ' Apply gravity
            testy = GXEntityVY(eid) / GXFrameRate
            IF testy < 1 THEN testy = 1
            tmove = __GX_EntityTestMove(eid, 0, testy, tpos, centity)
            IF tmove THEN
                ' calculate the number of seconds since the gravity started being applied
                DIM t
                t = (GXFrame - __gx_entities(eid).jumpstart) / GXFrameRate
                ' adjust the y velocity for gravity
                DIM g AS DOUBLE
                g = __gx_gravity * t ^ 2 / 2
                IF g < 1 THEN g = 1
                __gx_entities(eid).vy = __gx_entities(eid).vy + g
                IF GXEntityVY(eid) > __gx_terminal_velocity THEN GXEntityVY eid, __gx_terminal_velocity

            ELSEIF GXEntityVY(eid) >= 0 THEN
                '__gx_entities(eid).jumpstart = GXFrame
                __gx_entities(eid).jumpstart = GXFrame
                IF GXEntityVY(eid) <> 0 THEN
                    'DIM vy: vy = GXEntityVY(eid) * -.1
                    'IF ABS(vy) < 20 THEN vy = 0
                    GXEntityVY eid, 0

                    ' don't let the entity fall through the collision entity or tile
                    IF centity > 0 THEN
                        GXEntityPos eid, GXEntityX(eid), GXEntityY(centity) + GXEntityCollisionOffsetTop(centity) - GXEntityHeight(eid) + GXEntityCollisionOffsetBottom(eid)
                        'END IF
                        'IF tpos.y > -1 THEN
                    ELSE
                        GXEntityPos eid, GXEntityX(eid), tpos.y * GXTilesetHeight - GXEntityHeight(eid) + GXEntityCollisionOffsetBottom(eid)
                    END IF
                END IF
            END IF
        END IF

        IF GXEntityVX(eid) > 0 THEN
            ' Test right movement
            testx = GXEntityVX(eid) / GXFrameRate
            IF testx < 1 THEN testx = 1
            tmove = __GX_EntityTestMove(eid, testx, 0, tpos, centity)
            IF NOT tmove THEN
                ' stop the motion
                GXEntityVX eid, 0

                ' don't let the entity pass into the collision entity or tile
                IF centity > 0 THEN
                    GXEntityPos eid, GXEntityX(centity) + GXEntityCollisionOffsetLeft(centity) - GXEntityWidth(eid) + GXEntityCollisionOffsetRight(eid), GXEntityY(eid)
                END IF
                IF tpos.x > -1 THEN
                    GXEntityPos eid, tpos.x * GXTilesetWidth - GXEntityWidth(eid) + GXEntityCollisionOffsetRight(eid), GXEntityY(eid)
                END IF
            END IF

        ELSEIF GXEntityVX(eid) < 0 THEN
            ' Test left movement
            testx = GXEntityVX(eid) / GXFrameRate
            IF testx > -1 THEN testx = -1
            tmove = __GX_EntityTestMove(eid, testx, 0, tpos, centity)
            IF NOT tmove THEN
                ' stop the motion
                GXEntityVX eid, 0

                ' don't let the entity pass into the collision entity or tile
                IF centity > 0 THEN
                    GXEntityPos eid, GXEntityX(centity) + GXEntityWidth(centity) - GXEntityCollisionOffsetRight(centity) - GXEntityCollisionOffsetLeft(eid), GXEntityY(eid)
                END IF
                IF tpos.x > -1 THEN
                    GXEntityPos eid, (tpos.x + 1) * GXTilesetWidth - GXEntityCollisionOffsetLeft(eid), GXEntityY(eid)
                END IF
            END IF
        END IF

    END SUB


    ' Stop the game loop.
    ' This method will cause the game loop to end and return control to the calling program.
    SUB GXSceneStop
        __gx_scene.active = 0
    END SUB



    SUB GXMapCreate (columns AS INTEGER, rows AS INTEGER, layers AS INTEGER)
        __gx_map.columns = columns
        __gx_map.rows = rows
        __gx_map.layers = layers
        __gx_map.version = 2

        DIM layerSize AS LONG
        layerSize = rows * columns
        REDIM __gx_map_layers(layerSize, layers) AS GXMapTile
        REDIM __gx_map_layer_info(layers) AS GXMapLayer
        DIM l AS INTEGER
        FOR l = 1 TO layers
            __gx_map_layer_info(l).id = l
        NEXT l
    END SUB

    FUNCTION GXMapColumns%
        GXMapColumns = __gx_map.columns
    END FUNCTION

    FUNCTION GXMapRows%
        GXMapRows = __gx_map.rows
    END FUNCTION

    FUNCTION GXMapLayers%
        GXMapLayers = __gx_map.layers
    END FUNCTION

    SUB GXMapLayerVisible (layer AS INTEGER, visible AS INTEGER)
        __gx_map_layer_info(layer).hidden = NOT visible
    END SUB

    FUNCTION GXMapLayerVisible% (layer AS INTEGER)
        GXMapLayerVisible = NOT __gx_map_layer_info(layer).hidden
    END FUNCTION

    SUB GXMapLayerAdd
        REDIM _PRESERVE __gx_map_layer_info(GXMapLayers + 1) AS GXMapLayer
        REDIM _PRESERVE __gx_map_layers(GXMapRows * GXMapColumns, GXMapLayers + 1) AS GXMapTile
        __gx_map_layer_info(GXMapLayers + 1).id = GXMapLayers + 1
        __gx_map.layers = GXMapLayers + 1
    END SUB

    SUB GXMapLayerInsert (beforeLayer AS INTEGER)
        IF beforeLayer < 1 OR beforeLayer > GXMapLayers THEN EXIT SUB

        GXMapLayerAdd
        DIM layer AS INTEGER
        DIM tile AS INTEGER
        FOR layer = GXMapLayers TO beforeLayer + 1 STEP -1
            'gx_map_layer_info(layer) = gx_map_layer_info(layer - 1)
            FOR tile = 0 TO GXMapRows * GXMapColumns
                __gx_map_layers(tile, layer) = __gx_map_layers(tile, layer - 1)
            NEXT tile
        NEXT layer
        DIM blankTile AS GXMapTile
        FOR tile = 0 TO GXMapRows * GXMapColumns
            __gx_map_layers(tile, beforeLayer) = blankTile
        NEXT tile
    END SUB

    SUB GXMapLayerRemove (removeLayer AS INTEGER)
        IF removeLayer < 1 OR removeLayer > GXMapLayers OR GXMapLayers < 2 THEN EXIT SUB

        DIM layer AS INTEGER
        DIM tile AS INTEGER
        FOR layer = removeLayer TO GXMapLayers - 1
            FOR tile = 0 TO GXMapRows * GXMapColumns
                __gx_map_layers(tile, layer) = __gx_map_layers(tile, layer + 1)
            NEXT tile
        NEXT layer

        REDIM _PRESERVE __gx_map_layer_info(GXMapLayers - 1) AS GXMapLayer
        REDIM _PRESERVE __gx_map_layers(GXMapRows * GXMapColumns, GXMapLayers - 1) AS GXMapTile
        __gx_map.layers = GXMapLayers - 1
    END SUB

    SUB GXMapResize (columns AS INTEGER, rows AS INTEGER)
        DIM tempMap(GXMapRows * GXMapColumns, GXMapLayers) AS GXMapTile
        DIM m1 AS _MEM: m1 = _MEM(__gx_map_layers())
        DIM m2 AS _MEM: m2 = _MEM(tempMap())
        _MEMCOPY m1, m1.OFFSET, m1.SIZE TO m2, m2.OFFSET
        _MEMFREE m1
        _MEMFREE m2

        REDIM __gx_map_layers(rows * columns, GXMapLayers) AS GXMapTile

        DIM layer AS INTEGER
        DIM row AS INTEGER
        DIM column AS INTEGER
        DIM maxColumns AS INTEGER
        DIM maxRows AS INTEGER
        IF columns > GXMapColumns THEN
            maxColumns = GXMapColumns
        ELSE
            maxColumns = columns
        END IF
        IF rows > GXMapRows THEN
            maxRows = GXMapRows
        ELSE
            maxRows = rows
        END IF

        DIM blankTile AS GXMapTile
        FOR layer = 1 TO GXMapLayers
            FOR row = 0 TO maxRows - 1
                FOR column = 0 TO maxColumns - 1
                    IF column >= GXMapColumns OR row >= GXMapRows THEN
                        __gx_map_layers(row * columns + column, layer) = blankTile
                    ELSE
                        __gx_map_layers(row * columns + column, layer) = tempMap(row * GXMapColumns + column, layer)
                    END IF
                NEXT column
            NEXT row
        NEXT layer

        __gx_map.columns = columns
        __gx_map.rows = rows
    END SUB

    SUB GXMapDraw
        IF GXMapRows < 1 THEN EXIT SUB

        DIM tpos AS GXPosition
        DIM srow, scol, row, col
        DIM layer AS INTEGER, li AS INTEGER
        DIM xoffset, yoffset, pcol, prow AS LONG
        DIM t AS LONG, tx AS LONG, ty AS LONG
        DIM rowOffset AS LONG
        DIM colOffset AS LONG

        xoffset = GXSceneX MOD GXTilesetWidth
        pcol = FIX(GXSceneX / GXTilesetWidth)
        IF GXMapIsometric THEN
            prow = FIX(GXSceneY / (GXTilesetWidth / 4))
            yoffset = GXSceneY MOD (GXTilesetWidth / 4)
        ELSE
            prow = FIX(GXSceneY / GXTilesetHeight)
            yoffset = GXSceneY MOD GXTilesetHeight
        END IF

        FOR li = 1 TO GXMapLayers
            IF NOT __gx_map_layer_info(li).hidden THEN
                layer = __gx_map_layer_info(li).id

                srow = 0
                rowOffset = 0

                FOR row = prow TO prow + GXSceneRows + 1 'TODO: currently rendering too many rows for isometric maps
                    scol = 0
                    IF NOT GXMapIsometric THEN
                        colOffset = 0
                    ELSE
                        colOffset = 0
                        IF row MOD 2 = 0 THEN colOffset = GXTilesetWidth / 2
                    END IF

                    IF GXMapIsometric THEN
                        rowOffset = (row - prow + 1) * (GXTilesetHeight - GXTilesetWidth / 4)
                    END IF

                    FOR col = pcol TO pcol + GXSceneColumns + 1
                        t = GXMapTile(col, row, layer)
                        IF t > 0 THEN
                            DIM t1 AS INTEGER: t1 = t
                            t = __GX_TileFrame(t)
                            GXTilesetPos t, tpos
                            tx = scol * GXTilesetWidth - xoffset - colOffset
                            ty = srow * GXTilesetHeight - yoffset - rowOffset
                            GXSpriteDraw GXTilesetImage, tx, ty, tpos.y, tpos.x, GXTilesetWidth, GXTilesetHeight, __gx_scene.image
                        END IF
                        scol = scol + 1
                    NEXT col
                    srow = srow + 1
                NEXT row

            END IF ' layer is not hidden
            __GX_DrawEntityLayer li
        NEXT li

        ' Perform tile animation
        FOR t = 1 TO GXTilesetColumns * GXTilesetRows
            __GX_TileFrameNext t
        NEXT t
    END SUB

    SUB GXMapTilePosAt (x AS INTEGER, y AS INTEGER, tpos AS GXPosition)
        IF NOT GXMapIsometric THEN
            tpos.x = FIX((x + GXSceneX) / GXTilesetWidth)
            tpos.y = FIX((y + GXSceneY) / GXTilesetHeight)
        ELSE
            DIM tileWidthHalf AS INTEGER: tileWidthHalf = GXTilesetWidth / 2
            DIM tileHeightHalf AS INTEGER: tileHeightHalf = GXTilesetHeight / 2
            DIM sx AS LONG: sx = x / tileWidthHalf

            DIM offset AS INTEGER
            IF sx MOD 2 = 1 THEN
                offset = tileWidthHalf
            ELSE
                offset = 0
            END IF

            tpos.y = (2 * y) / tileHeightHalf
            tpos.x = (x - offset) / GXTilesetWidth
        END IF
    END SUB

    FUNCTION __GX_TileFrame% (tileId)
        IF tileId < 0 OR tileId > UBOUND(__gx_tileset_tiles) THEN
            __GX_TileFrame = tileId
            EXIT FUNCTION
        END IF

        IF __gx_tileset_tiles(tileId).animationId = 0 THEN
            __GX_TileFrame = tileId
            EXIT FUNCTION
        END IF

        DIM currFrame AS INTEGER
        currFrame = __gx_tileset_tiles(tileId).animationId
        IF __gx_tileset_tiles(tileId).animationFrame > 0 THEN
            currFrame = __gx_tileset_tiles(tileId).animationFrame
        END IF

        __GX_TileFrame = __gx_tileset_animations(currFrame).tileId
    END FUNCTION


    SUB __GX_TileFrameNext (tileId AS LONG)
        IF tileId < 0 OR tileId > UBOUND(__gx_tileset_tiles) THEN EXIT SUB
        IF __gx_tileset_tiles(tileId).animationId = 0 THEN EXIT SUB

        DIM frame AS INTEGER
        frame = GXFrame MOD GXFrameRate + 1

        DIM firstFrame AS INTEGER
        firstFrame = __gx_tileset_tiles(tileId).animationId

        DIM animationSpeed AS INTEGER
        animationSpeed = __gx_tileset_tiles(tileId).animationSpeed

        IF frame MOD (GXFrameRate / animationSpeed) = 0 THEN
            DIM currFrame AS INTEGER
            currFrame = firstFrame
            IF __gx_tileset_tiles(tileId).animationFrame > 0 THEN
                currFrame = __gx_tileset_tiles(tileId).animationFrame
            END IF

            DIM nextFrame AS INTEGER
            nextFrame = __gx_tileset_animations(currFrame).nextFrame
            IF nextFrame = 0 THEN
                nextFrame = firstFrame
            END IF

            __gx_tileset_tiles(tileId).animationFrame = nextFrame
        END IF
    END SUB


    SUB GXMapTile (col AS INTEGER, row AS INTEGER, layer AS INTEGER, tile AS INTEGER)
        IF tile < 0 THEN EXIT SUB
        'TODO: check for tile greater than max and exit early

        IF (col >= 0 AND col <= GXMapColumns AND row >= 0 AND row < GXMapRows) THEN
            DIM mpos AS LONG
            mpos = row * GXMapColumns + col
            __gx_map_layers(mpos, layer).tile = tile
        END IF
    END SUB

    FUNCTION GXMapTile% (col AS INTEGER, row AS INTEGER, layer AS INTEGER)
        IF col < 0 OR col >= GXMapColumns OR row < 0 OR row >= GXMapRows OR layer > GXMapLayers THEN
            GXMapTile = 0
        ELSE
            DIM mpos AS LONG
            mpos = row * GXMapColumns + col
            GXMapTile = __gx_map_layers(mpos, layer).tile
        END IF
    END FUNCTION

    FUNCTION GXMapTileDepth% (col AS INTEGER, row AS INTEGER)
        IF col < 0 OR col >= GXMapColumns OR row < 0 OR row >= GXMapRows THEN
            GXMapTileDepth = 0
        ELSE
            DIM layer AS INTEGER
            FOR layer = GXMapLayers TO 1 STEP -1
                IF GXMapTile(col, row, layer) > 0 THEN
                    GXMapTileDepth = layer
                    EXIT FUNCTION
                END IF
            NEXT layer
            GXMapTileDepth = 0
        END IF
    END FUNCTION

    SUB GXMapTileAdd (col AS INTEGER, row AS INTEGER, tile AS INTEGER)
        IF tile < 1 THEN EXIT SUB
        'TODO: check for tile greater than max and exit early

        IF (col >= 0 AND col <= GXMapColumns AND row >= 0 AND row <= GXMapRows) THEN
            DIM layer AS INTEGER
            FOR layer = 1 TO GXMapLayers
                IF GXMapTile(col, row, layer) = 0 THEN
                    GXMapTile col, row, layer, tile
                    EXIT SUB
                END IF
            NEXT layer
        END IF
    END SUB

    SUB GXMapTileRemove (col AS INTEGER, row AS INTEGER)
        IF (col >= 0 AND col <= GXMapColumns AND row >= 0 AND row < GXMapRows) THEN
            DIM layer AS INTEGER
            FOR layer = GXMapLayers TO 1 STEP -1
                IF GXMapTile(col, row, layer) THEN
                    GXMapTile col, row, layer, 0
                    EXIT SUB
                END IF
            NEXT layer
        END IF
    END SUB

    FUNCTION GXMapVersion%
        GXMapVersion = __gx_map.version
    END FUNCTION

    SUB GXMapSave (filename AS STRING)
        DIM version AS INTEGER
        DIM col AS INTEGER
        DIM row AS INTEGER
        DIM layer AS INTEGER
        DIM tile AS INTEGER
        DIM depth AS INTEGER

        version = 2

        ' TODO: check to see if the tileset image has been removed before deleting
        '       the original file
        IF _FILEEXISTS(filename) THEN
            KILL filename
        END IF
        OPEN filename FOR BINARY AS #1

        ' Save the map version
        PUT #1, , version

        ' Save the map meta-data
        PUT #1, , __gx_map.columns
        PUT #1, , __gx_map.rows
        PUT #1, , __gx_map.layers
        PUT #1, , __gx_map.isometric

        ' Save the map tile layer data
        ' TODO: use a temp file strategy that will avoid file collisions
        '       or potentially read and write from memory instead
        OPEN "./tmp/layer" FOR BINARY AS #2
        PUT #2, , __gx_map_layers()
        CLOSE #2
        OPEN "./tmp/layer" FOR BINARY AS #2
        DIM lstr AS STRING
        lstr = STRING$(LOF(2), " ")
        GET #2, , lstr
        CLOSE #2
        KILL "./tmp/layer"
        lstr = _DEFLATE$(lstr)
        __GX_WriteString lstr

        ' Save the tilemap information
        __GX_TilesetSave

        CLOSE #1
    END SUB

    SUB GXMapSaveWeb (filename AS STRING)
        DIM version AS INTEGER
        DIM col AS INTEGER
        DIM row AS INTEGER
        DIM layer AS INTEGER
        DIM tile AS INTEGER
        DIM depth AS INTEGER

        version = 2

        ' TODO: check to see if the tileset image has been removed before deleting
        '       the original file
        IF _FILEEXISTS(filename) THEN
            KILL filename
        END IF
        OPEN filename FOR OUTPUT AS #1

        PRINT #1, "{"
        ' Save the map version
        PRINT #1, __JSL("version"); version; ","

        ' Save the map meta-data
        PRINT #1, __JSL("columns"); __gx_map.columns; ","
        PRINT #1, __JSL("rows"); __gx_map.rows; ","
        'Print #1, __JSL("layers"); __gx_map.layers; ","
        PRINT #1, __JSL("isometric"); __gx_map.isometric; ","


        ' Save the map tile layer data
        PRINT #1, __JSL("layers"); "["
        FOR layer = 1 TO GXMapLayers
            PRINT #1, "[";
            FOR row = 0 TO GXMapRows - 1
                FOR col = 0 TO GXMapColumns - 1
                    PRINT #1, GXMapTile(col, row, layer);
                    IF col = GXMapColumns - 1 AND row = GXMapRows - 1 THEN
                        'No comma
                    ELSE
                        PRINT #1, ",";
                    END IF
                NEXT col
                PRINT #1, ""
            NEXT row
            IF layer < GXMapLayers THEN
                PRINT #1, "],"
            ELSE
                PRINT #1, "]"
            END IF
        NEXT layer
        PRINT #1, "],"

        ' Save the tilemap information
        __GX_TilesetSaveWeb filename + ".png"

        PRINT #1, "}"
        CLOSE #1
    END SUB

    FUNCTION __JSL$ (s AS STRING)
        ' wrap the string in double quotes
        __JSL = CHR$(34) + s + CHR$(34) + ":"
    END FUNCTION

    ' Load the map
    SUB GXMapLoad (filename AS STRING)
        __gx_map_loading = 1

        OPEN filename FOR BINARY AS #1

        ' Read the version
        GET #1, 1, __gx_map.version

        ' For backwards compatibility, add new versions of the
        ' load function to continue to support older maps
        SELECT CASE GXMapVersion
            CASE 1: __GX_MapLoadV1 filename
            CASE 2: __GX_MapLoadV2 filename
        END SELECT

        CLOSE #1

        __gx_map_loading = 0
    END SUB

    ' Load a version 2 map
    SUB __GX_MapLoadV2 (filename AS STRING)
        DIM columns AS INTEGER
        DIM rows AS INTEGER
        DIM layers AS INTEGER
        DIM col AS INTEGER
        DIM row AS INTEGER
        DIM layer AS INTEGER
        DIM depth AS INTEGER
        DIM tile AS INTEGER

        GET #1, , columns
        GET #1, , rows
        GET #1, , layers
        GET #1, , __gx_map.isometric
        GXMapCreate columns, rows, layers
        '--------------------------------------------------------------
        ' temporary code - remove
        '--------------------------------------------------------------
        'DIM temp(layers, columns * rows) AS GXMapTile
        '--------------------------------------------------------------
        ' END temporary code - remove
        '--------------------------------------------------------------


        ' Read the map tile layer data
        DIM lstr AS STRING
        lstr = __GX_ReadString
        lstr = _INFLATE$(lstr)
        ' TODO: use a temp file strategy that will avoid file collisions
        '       or potentially read and write from memory instead
        IF NOT _DIREXISTS("./tmp") THEN MKDIR "./tmp"
        OPEN "./tmp/layer" FOR BINARY AS #2
        PUT #2, , lstr
        CLOSE #2
        OPEN "./tmp/layer" FOR BINARY AS #2
        GET #2, , __gx_map_layers()
        CLOSE #2
        KILL "./tmp/layer"

        '--------------------------------------------------------------
        ' temporary code - remove
        '--------------------------------------------------------------
        'DIM l AS INTEGER, t AS INTEGER
        'FOR l = 1 TO layers
        '    FOR t = 0 TO columns * rows
        '        gx_map_layers(t, l) = temp(l, t)
        '    NEXT t
        'NEXT l
        '--------------------------------------------------------------
        ' END temporary code - remove
        '--------------------------------------------------------------


        ' Read the tileset information
        __GX_TilesetLoad
        'DIM tilesetFilename AS STRING
        'DIM tilewidth AS INTEGER
        'DIM tileheight AS INTEGER
        'tilesetFilename = __GX_ReadString ' original tileset filename
        'GET #1, , tilewidth
        'GET #1, , tileheight

        '' If the map has an embedded tileset image, save it to a temp file location
        'DIM tsize AS LONG
        'GET #1, , tsize
        'IF NOT EOF(1) THEN
        '    DIM tmpfile AS STRING
        '    DIM bytes(tsize) AS _UNSIGNED _BYTE
        '    tmpfile = __GXFS_RemoveFileExtension(__GXFS_GetFilename(filename)) + ".ts1"
        '    IF NOT _DIREXISTS("./tmp") THEN MKDIR ("./tmp")
        '    tilesetFilename = "./tmp/" + tmpfile
        '    GET #1, , bytes()
        '    OPEN tilesetFilename FOR BINARY AS #2
        '    PUT #2, , bytes()
        '    CLOSE #2
        '    GXTilesetCreate tilesetFilename, tilewidth, tileheight
        'ELSE
        '    GXTilesetCreate tilesetFilename, tilewidth, tileheight
        'END IF

    END SUB


    ' Load a version 1 map
    SUB __GX_MapLoadV1 (filename AS STRING)
        DIM columns AS INTEGER
        DIM rows AS INTEGER
        DIM col AS INTEGER
        DIM row AS INTEGER
        DIM layer AS INTEGER
        DIM depth AS INTEGER
        DIM tile AS INTEGER

        GET #1, , columns
        GET #1, , rows

        GXMapCreate columns, rows, 3
        __gx_map.version = 1

        FOR row = 0 TO rows - 1
            FOR col = 0 TO columns - 1
                GET #1, , depth
                IF depth > 0 THEN
                    FOR layer = 1 TO depth
                        GET #1, , tile
                        GXMapTile col, row, layer, tile + 1
                    NEXT layer
                END IF
            NEXT col
        NEXT row

        ' Read the tileset information
        DIM tilesetFilename AS STRING
        DIM tilewidth AS INTEGER
        DIM tileheight AS INTEGER
        tilesetFilename = __GX_ReadString_V1 ' original tileset filename
        GET #1, , tilewidth
        GET #1, , tileheight

        ' If the map has an embedded tileset image, save it to a temp file location
        DIM tsize AS LONG
        GET #1, , tsize
        IF NOT EOF(1) THEN
            DIM tmpfile AS STRING
            DIM bytes(tsize) AS _UNSIGNED _BYTE
            tmpfile = GXFS_RemoveFileExtension(GXFS_GetFilename(filename)) + ".ts1"
            IF NOT _DIREXISTS("./tmp") THEN MKDIR ("./tmp")
            tilesetFilename = "./tmp/" + tmpfile
            GET #1, , bytes()
            OPEN tilesetFilename FOR BINARY AS #2
            PUT #2, , bytes()
            CLOSE #2
            GXTilesetCreate tilesetFilename, tilewidth, tileheight
        ELSE
            GXTilesetCreate tilesetFilename, tilewidth, tileheight
        END IF
    END SUB



    FUNCTION GXMapIsometric%
        GXMapIsometric = __gx_map.isometric
    END FUNCTION

    SUB GXMapIsometric (iso AS INTEGER)
        __gx_map.isometric = iso
        __GX_UpdateSceneSize
    END SUB


    SUB GXSpriteDraw (i AS LONG, x AS LONG, y AS LONG, seq AS INTEGER, frame AS INTEGER, swidth AS INTEGER, sheight AS INTEGER, imgdest AS LONG)
        GXSpriteDrawScaled i, x, y, swidth, sheight, seq, frame, swidth, sheight, imgdest
    END SUB

    SUB GXSpriteDrawScaled (i AS LONG, x AS LONG, y AS LONG, dwidth AS INTEGER, dheight AS INTEGER, seq AS INTEGER, frame AS INTEGER, swidth AS INTEGER, sheight AS INTEGER, imgdest AS LONG)
        DIM xoffset, yoffset
        xoffset = (frame - 1) * swidth
        yoffset = (seq - 1) * sheight
        IF imgdest THEN
            ' i, imgdest
            'Dim a: Input a
            _PUTIMAGE (x, y)-(x + (dwidth - 1), y + (dheight - 1)), i, imgdest, (xoffset, yoffset)-(xoffset + (swidth - 1), yoffset + (sheight - 1))
        ELSE
            _PUTIMAGE (x, y)-(x + (dwidth - 1), y + (dheight - 1)), i, , (xoffset, yoffset)-(xoffset + (swidth - 1), yoffset + (sheight - 1))
        END IF
    END SUB


    ' Tileset Methods
    ' ----------------------------------------------------------------------------
    SUB GXTilesetCreate (tilesetFilename AS STRING, tileWidth AS INTEGER, tileHeight AS INTEGER)
        GXTilesetReplaceImage tilesetFilename, tileWidth, tileHeight

        REDIM __gx_tileset_tiles(GXTilesetColumns * GXTilesetRows) AS GXTile
        'REDIM __gx_tileset_animations(0) AS GXTile
    END SUB

    SUB GXTilesetReplaceImage (tilesetFilename AS STRING, tilewidth AS INTEGER, tileheight AS INTEGER)
        __gx_tileset.filename = tilesetFilename
        __gx_tileset.width = tilewidth
        __gx_tileset.height = tileheight

        DIM tswidth, tsheight
        __gx_tileset.image = __GX_ImageLoad(tilesetFilename)
        tswidth = _WIDTH(GXTilesetImage)
        tsheight = _HEIGHT(GXTilesetImage)

        __gx_tileset.columns = tswidth / GXTilesetWidth
        __gx_tileset.rows = tsheight / GXTilesetHeight

        'gx_scene.columns = FIX(gx_scene.width / gx_tileset.width)
        'gx_scene.rows = FIX(gx_scene.height / gx_tileset.height)
        __GX_UpdateSceneSize
    END SUB

    SUB GXTilesetLoad (filename AS STRING)
        OPEN filename FOR BINARY AS #1
        __GX_TilesetLoad
        CLOSE #1
    END SUB

    SUB __GX_TilesetLoad
        DIM version AS INTEGER
        version = 1

        ' Save the tileset version
        GET #1, , version

        ' Save the tileset image meta-data
        __gx_tileset.filename = __GX_ReadString
        GET #1, , __gx_tileset.width
        GET #1, , __gx_tileset.height

        ' Read the tileset image data and save to a temporary location
        DIM tsize AS LONG
        GET #1, , tsize
        DIM tmpfile AS STRING
        DIM tilesetFilename AS STRING
        DIM bytes(tsize) AS _UNSIGNED _BYTE
        tmpfile = GXFS_RemoveFileExtension(GXFS_GetFilename(GXTilesetFilename)) + ".gxi"
        IF NOT _DIREXISTS("./tmp") THEN MKDIR ("./tmp")
        tilesetFilename = "./tmp/" + tmpfile
        GET #1, , bytes()
        OPEN tilesetFilename FOR BINARY AS #2
        PUT #2, , bytes()
        CLOSE #2
        GXTilesetCreate tilesetFilename, GXTilesetWidth, GXTilesetHeight

        ' Read the tileset tile data
        DIM asize AS INTEGER
        GET #1, , asize
        REDIM __gx_tileset_tiles(asize) AS GXTile
        GET #1, , __gx_tileset_tiles()

        ' Read the tileset animation data
        GET #1, , asize
        REDIM __gx_tileset_animations(asize) AS GXTileFrame
        GET #1, , __gx_tileset_animations()
    END SUB

    SUB GXTilesetSave (filename AS STRING)
        OPEN filename FOR BINARY AS #1
        __GX_TilesetSave
        CLOSE #1
    END SUB

    SUB __GX_TilesetSave
        DIM version AS INTEGER
        version = 1

        ' Save the tileset version
        PUT #1, , version

        ' Save the tileset image meta-data
        __GX_WriteString GXTilesetFilename
        PUT #1, , __gx_tileset.width
        PUT #1, , __gx_tileset.height

        ' Save the tileset image data
        DIM tsize AS LONG
        OPEN GXTilesetFilename FOR BINARY AS #2
        tsize = LOF(2)
        PUT #1, , tsize

        DIM bytes(tsize) AS _UNSIGNED _BYTE
        GET #2, , bytes()
        PUT #1, , bytes()
        CLOSE #2

        ' Save the tileset tile data
        DIM asize AS INTEGER
        asize = UBOUND(__gx_tileset_tiles)
        PUT #1, , asize
        PUT #1, , __gx_tileset_tiles()

        ' Save the tileset animation data
        asize = UBOUND(__gx_tileset_animations)
        PUT #1, , asize
        PUT #1, , __gx_tileset_animations()
    END SUB

    SUB __GX_TilesetSaveWeb (tilesetFilename AS STRING)

        PRINT #1, __JSL("tileset"); "{"

        ' Save the tileset version
        'Put #1, , version

        ' Save the tileset image meta-data
        PRINT #1, __JSL("width"); __gx_tileset.width; ","
        PRINT #1, __JSL("height"); __gx_tileset.height; ","
        PRINT #1, __JSL("image"); CHR$(34) + "map/" + GXFS_GetFilename(tilesetFilename) + CHR$(34); ","

        ' Save the tileset image data
        DIM tsize AS LONG
        OPEN GXTilesetFilename FOR BINARY AS #2
        tsize = LOF(2)
        'Put #1, , tsize

        OPEN tilesetFilename FOR BINARY AS #3
        DIM bytes(tsize) AS _UNSIGNED _BYTE
        GET #2, , bytes()
        PUT #3, , bytes()
        CLOSE #2
        CLOSE #3

        ' Save the tileset tile data
        DIM i AS INTEGER
        PRINT #1, __JSL$("tiles") + " ["
        FOR i = 1 TO UBOUND(__gx_tileset_tiles)
            IF i > 1 THEN PRINT #1, ",";
            PRINT #1, "["; _TRIM$(STR$(__gx_tileset_tiles(i).animationId)); ",";
            PRINT #1, _TRIM$(STR$(__gx_tileset_tiles(i).animationSpeed)); ",";
            PRINT #1, _TRIM$(STR$(__gx_tileset_tiles(i).animationFrame)); "]";
        NEXT i
        PRINT #1, "],"

        PRINT #1, __JSL$("animations") + " ["
        FOR i = 1 TO UBOUND(__gx_tileset_animations)
            IF i > 1 THEN PRINT #1, ",";
            PRINT #1, "["; _TRIM$(STR$(__gx_tileset_animations(i).tileId)); ",";
            PRINT #1, _TRIM$(STR$(__gx_tileset_animations(i).firstFrame)); ",";
            PRINT #1, _TRIM$(STR$(__gx_tileset_animations(i).nextFrame)); "]";
        NEXT i

        PRINT #1, "]"
        PRINT #1, "}"
    END SUB


    SUB GXTilesetPos (tilenum AS INTEGER, p AS GXPosition)
        IF GXTilesetColumns = 0 THEN
            p.x = 0
            p.y = 0
        ELSE
            p.y = FIX((tilenum - 1) / GXTilesetColumns)
            p.y = p.y + 1
            p.x = (tilenum - 1) MOD GXTilesetColumns + 1
        END IF
    END SUB

    FUNCTION GXTilesetWidth%
        GXTilesetWidth = __gx_tileset.width
    END FUNCTION

    FUNCTION GXTilesetHeight%
        GXTilesetHeight = __gx_tileset.height
    END FUNCTION

    FUNCTION GXTilesetColumns%
        GXTilesetColumns = __gx_tileset.columns
    END FUNCTION

    FUNCTION GXTilesetRows%
        GXTilesetRows = __gx_tileset.rows
    END FUNCTION

    FUNCTION GXTilesetFilename$
        GXTilesetFilename = __gx_tileset.filename
    END FUNCTION

    FUNCTION GXTilesetImage&
        GXTilesetImage = __gx_tileset.image
    END FUNCTION

    SUB GXTilesetAnimationCreate (tileId AS INTEGER, animationSpeed AS INTEGER)
        DIM frameId AS INTEGER
        frameId = UBOUND(__gx_tileset_animations) + 1
        REDIM _PRESERVE __gx_tileset_animations(frameId) AS GXTileFrame
        __gx_tileset_animations(frameId).tileId = tileId
        __gx_tileset_animations(frameId).firstFrame = frameId
        __gx_tileset_tiles(tileId).animationId = frameId
        __gx_tileset_tiles(tileId).animationSpeed = animationSpeed
    END SUB

    SUB GXTilesetAnimationAdd (firstTileId AS INTEGER, addTileId AS INTEGER)
        DIM firstFrame AS INTEGER
        firstFrame = __gx_tileset_tiles(firstTileId).animationId

        ' find the last frame
        DIM lastFrame AS INTEGER
        lastFrame = firstFrame
        WHILE __gx_tileset_animations(lastFrame).nextFrame > 0
            lastFrame = __gx_tileset_animations(lastFrame).nextFrame
        WEND

        DIM frameId AS INTEGER
        frameId = UBOUND(__gx_tileset_animations) + 1
        REDIM _PRESERVE __gx_tileset_animations(frameId) AS GXTileFrame
        __gx_tileset_animations(frameId).tileId = addTileId
        __gx_tileset_animations(frameId).firstFrame = firstFrame
        __gx_tileset_animations(lastFrame).nextFrame = frameId
    END SUB

    SUB GXTilesetAnimationRemove (firstTileId AS INTEGER)
        ' TODO: replace with implementation that will remove unused
        '       animation data from the array
        __gx_tileset_tiles(firstTileId).animationId = 0
    END SUB

    FUNCTION GXTilesetAnimationFrames% (tileId AS INTEGER, tileFrames() AS INTEGER)
        IF tileId < 0 OR tileId > GXTilesetRows * GXTilesetColumns THEN
            GXTilesetAnimationFrames = 0
            EXIT FUNCTION
        END IF

        REDIM tileFrames(0) AS INTEGER
        DIM frame AS INTEGER
        DIM frameCount AS INTEGER
        frameCount = 0
        frame = __gx_tileset_tiles(tileId).animationId
        WHILE frame > 0
            frameCount = frameCount + 1
            REDIM _PRESERVE tileFrames(frameCount) AS INTEGER
            tileFrames(frameCount) = __gx_tileset_animations(frame).tileId
            frame = __gx_tileset_animations(frame).nextFrame
        WEND
        GXTilesetAnimationFrames = frameCount
    END FUNCTION

    FUNCTION GXTilesetAnimationSpeed% (tileId AS INTEGER)
        IF tileId > GXTilesetRows * GXTilesetColumns THEN EXIT FUNCTION
        GXTilesetAnimationSpeed = __gx_tileset_tiles(tileId).animationSpeed
    END FUNCTION

    SUB GXTilesetAnimationSpeed (tileId AS INTEGER, speed AS INTEGER)
        __gx_tileset_tiles(tileId).animationSpeed = speed
    END SUB

    ' Bitmap Font Methods
    ' ----------------------------------------------------------------------------
    FUNCTION GXFontCreate% (filename AS STRING, charWidth AS INTEGER, charHeight AS INTEGER, charref AS STRING)
        __gx_font_count = __gx_font_count + 1
        REDIM _PRESERVE __gx_fonts(__gx_font_count) AS GXFont
        REDIM _PRESERVE __gx_font_charmap(256, __gx_font_count) AS GXPosition

        ' Create a new game entity
        __gx_fonts(__gx_font_count).eid = GXEntityCreate(filename, charWidth, charHeight, 1)
        ' Hide the entity as we will not be displaying it as a normal sprite
        GXEntityVisible __gx_fonts(__gx_font_count).eid, GX_FALSE

        ' map the character codes to the image location
        __GX_FontMapChars __gx_font_count, charref

        GXFontCreate = __gx_font_count
    END FUNCTION

    SUB GXFontCreate (filename AS STRING, charWidth AS INTEGER, charHeight AS INTEGER, charref AS STRING, uid AS STRING)
        DIM fid AS INTEGER
        fid = GXFontCreate(filename, charWidth, charHeight, charref)
        __GX uid, fid, GXTYPE_FONT
    END SUB

    FUNCTION GXFontWidth% (fid AS LONG)
        GXFontWidth = GXEntityWidth(__gx_fonts(fid).eid)
    END FUNCTION

    FUNCTION GXFontHeight% (fid AS LONG)
        GXFontHeight = GXEntityHeight(__gx_fonts(fid).eid)
    END FUNCTION

    FUNCTION GXFontCharSpacing% (fid AS LONG)
        GXFontCharSpacing = __gx_fonts(fid).charSpacing
    END FUNCTION

    SUB GXFontCharSpacing (fid AS LONG, charSpacing AS INTEGER)
        __gx_fonts(fid).charSpacing = charSpacing
    END SUB

    FUNCTION GXFontLineSpacing% (fid AS LONG)
        GXFontLineSpacing = __gx_fonts(fid).lineSpacing
    END FUNCTION

    SUB GXFontLineSpacing (fid AS LONG, lineSpacing AS INTEGER)
        __gx_fonts(fid).lineSpacing = lineSpacing
    END SUB

    SUB GXDrawText (fid AS INTEGER, sx AS LONG, sy AS LONG, s AS STRING)
        IF fid = GXFONT_DEFAULT OR fid = GXFONT_DEFAULT_BLACK THEN
            IF __gx_fonts(fid).eid = 0 THEN __GX_FontCreateDefault fid
        END IF

        DIM i AS INTEGER
        DIM a AS INTEGER
        DIM c AS STRING
        DIM cpos AS GXPosition
        DIM x AS LONG: x = sx
        DIM y AS LONG: y = sy
        DIM font AS GXFont: font = __gx_fonts(fid)
        DIM e AS GXEntity: e = __gx_entities(font.eid)

        FOR i = 1 TO LEN(s)
            c = MID$(s, i, 1)
            a = ASC(c)
            IF a = 10 THEN ' Line feed, move down to the next line
                x = sx
                y = y + e.height + font.lineSpacing
            ELSEIF NOT a = 13 THEN ' Ignore Carriage Return
                IF NOT a = 32 THEN ' Space character, nothing to draw
                    cpos = __gx_font_charmap(a, fid)
                    GXSpriteDraw e.image, x, y, cpos.y, cpos.x, e.width, e.height, __gx_scene.image '0
                END IF
                x = x + e.width + font.charSpacing
            END IF
        NEXT i
    END SUB



    ' Debugging methods
    ' ----------------------------------------------------------------------------
    FUNCTION GXDebug%
        GXDebug = __gx_debug.enabled
    END FUNCTION

    SUB GXDebug (enabled AS INTEGER)
        __gx_debug.enabled = enabled
    END SUB

    FUNCTION GXDebugScreenEntities%
        GXDebugScreenEntities = __gx_debug.screenEntities
    END FUNCTION

    SUB GXDebugScreenEntities (enabled AS INTEGER)
        __gx_debug.screenEntities = enabled
    END SUB

    FUNCTION GXDebugFont%
        GXDebugFont = __gx_debug.font
    END FUNCTION

    SUB GXDebugFont (font AS INTEGER)
        __gx_debug.font = font
    END SUB

    FUNCTION GXDebugTileBorderColor~&
        GXDebugTileBorderColor = __gx_debug.tileBorderColor
    END FUNCTION

    SUB GXDebugTileBorderColor (c AS _UNSIGNED LONG)
        __gx_debug.tileBorderColor = c
    END SUB

    FUNCTION GXDebugEntityBorderColor~&
        GXDebugEntityBorderColor = __gx_debug.entityBorderColor
    END FUNCTION

    SUB GXDebugEntityBorderColor (c AS _UNSIGNED LONG)
        __gx_debug.entityBorderColor = c
    END SUB

    FUNCTION GXDebugEntityCollisionColor~&
        GXDebugEntityCollisionColor = __gx_debug.entityCollisionColor
    END FUNCTION

    SUB GXDebugEntityCollisionColor (c AS _UNSIGNED LONG)
        __gx_debug.entityCollisionColor = c
    END SUB

    SUB __GX_DebugMapTile

        DIM t AS INTEGER, tx AS LONG, ty AS LONG, depth AS INTEGER, i AS INTEGER
        DIM tpos AS GXPosition
        GXMapTilePosAt GXMouseX, GXMouseY, tpos
        depth = GXMapTileDepth(tpos.x, tpos.y)
        tx = tpos.x * GXTilesetWidth - GXSceneX
        ty = tpos.y * GXTilesetHeight - GXSceneY

        IF NOT GXHardwareAcceleration THEN
            DIM cdest AS LONG
            cdest = _DEST
            _DEST __gx_scene.image

            LINE (tx, ty)-(tx + GXTilesetWidth - 1, ty + GXTilesetHeight - 1), GXDebugTileBorderColor, B , &B1010101010101010

            _DEST cdest
        END IF
        GXDrawText GXDebugFont, tx, ty - 8, "(" + _TRIM$(STR$(tpos.x)) + "," + _TRIM$(STR$(tpos.y)) + ")"
        FOR i = 1 TO depth
            t = GXMapTile(tpos.x, tpos.y, i)
            GXDrawText GXDebugFont, tx, ty + GXTilesetHeight + 1 + (i - 1) * 8, _TRIM$(STR$(i)) + ":" + _TRIM$(STR$(t))
        NEXT i

    END SUB

    SUB __GX_DebugEntity (ent AS GXEntity, x, y)
        IF ent.screen AND NOT GXDebugScreenEntities THEN EXIT SUB

        ' Display the entity's position
        GXDrawText GXDebugFont, x, y - 8, "(" + __GX_DebugRound(ent.x, 2) + "," + __GX_DebugRound(ent.y, 2) + ")"

        IF NOT GXHardwareAcceleration THEN
            DIM odest AS LONG
            odest = _DEST
            _DEST __gx_scene.image

            ' Draw the entity's collision rect
            LINE (x + ent.coLeft, y + ent.coTop)-(x + ent.width - 1 - ent.coRight, y + ent.height - 1 - ent.coBottom), GXDebugEntityCollisionColor, B ', &B1010101010101010

            ' Draw the entity's bounding rect
            LINE (x, y)-(x + ent.width - 1, y + ent.height - 1), GXDebugEntityBorderColor, B , &B1010101010101010

            _DEST odest
        END IF
    END SUB

    FUNCTION __GX_DebugRound$ (n AS DOUBLE, decimalPlaces AS INTEGER)
        DIM n2 AS LONG
        n2 = _ROUND(n * 10 ^ decimalPlaces)
        IF n2 = 0 THEN
            __GX_DebugRound = "0." + STRING$(decimalPlaces, "0")
        ELSE
            DIM ns AS STRING, decimal AS STRING
            ns = _TRIM$(STR$(n2))
            decimal = RIGHT$(ns, decimalPlaces)
            ns = LEFT$(ns, LEN(ns) - decimalPlaces)
            __GX_DebugRound = ns + "." + decimal
        END IF
    END FUNCTION

    SUB __GX_DebugFrameRate
        DIM frame AS STRING
        DIM frameRate AS STRING
        frame = _TRIM$(STR$(GXFrame))
        frameRate = _TRIM$(STR$(GXFrameRate))
        frameRate = STRING$(LEN(frame) - LEN(frameRate), " ") + frameRate

        GXDrawText GXDebugFont, GXSceneWidth - (LEN(frame) + 6) * 6 - 1, 1, "FRAME:" + frame
        GXDrawText GXDebugFont, GXSceneWidth - (LEN(frameRate) + 4) * 6 - 1, 9, "FPS:" + frameRate
    END SUB



    ' GX Engine Miscellaneous Private Methods
    ' ----------------------------------------------------------------------------
    FUNCTION __GX_ImageLoad& (filename AS STRING)
        DIM id AS LONG
        DIM i AS INTEGER
        FOR i = 0 TO __gx_image_count - 1
            IF filename = __gx_images(i).filename THEN id = __gx_images(i).id
        NEXT i
        IF id = 0 THEN
            IF GXHardwareAcceleration THEN
                id = _LOADIMAGE(filename, 33)
            ELSE
                id = _LOADIMAGE(filename, 32) ', 33)
            END IF
            __gx_image_count = __gx_image_count + 1
            REDIM _PRESERVE __gx_images(__gx_image_count) AS GXImage
            __gx_images(__gx_image_count - 1).id = id
            __gx_images(__gx_image_count - 1).filename = filename
        END IF
        __GX_ImageLoad = id
    END FUNCTION


    SUB __GX_UpdateSceneSize
        IF GXTilesetWidth < 1 OR GXTilesetHeight < 1 THEN EXIT SUB
        IF GXMapIsometric THEN
            __gx_scene.columns = FIX(GXSceneWidth / GXTilesetWidth)
            __gx_scene.rows = GXSceneHeight / (GXTilesetWidth / 4)
        ELSE
            __gx_scene.columns = FIX(GXSceneWidth / GXTilesetWidth)
            __gx_scene.rows = FIX(GXSceneHeight / GXTilesetHeight)
        END IF
    END SUB

    SUB __GX_WriteString (s AS STRING)
        DIM l AS LONG
        l = LEN(s)
        PUT #1, , l
        PUT #1, , s
    END SUB

    FUNCTION __GX_ReadString$
        DIM s AS STRING
        DIM l AS LONG
        DIM i AS INTEGER
        GET #1, , l
        s = STRING$(l, " ")
        GET #1, , s
        __GX_ReadString = s
    END FUNCTION

    FUNCTION __GX_ReadString_V1$
        DIM s AS STRING
        DIM l AS INTEGER
        DIM i AS INTEGER
        DIM b AS _UNSIGNED _BYTE
        GET #1, , l
        FOR i = 1 TO l
            GET #1, , b
            s = s + CHR$(b)
        NEXT i
        __GX_ReadString_V1 = s
    END FUNCTION

    FUNCTION GXEntityCollide% (eid1, eid2)
            GXEntityCollide = __GX_RectCollide( _
            GXEntityX(eid1) + GXEntityCollisionOffsetLeft(eid1), _
            GXEntityY(eid1) + GXEntityCollisionOffsetTop(eid1), _
            GXEntityWidth(eid1) - GXEntityCollisionOffsetLeft(eid1) - GXEntityCollisionOffsetRight(eid1) - 1, _
            GXEntityHeight(eid1) - GXEntityCollisionOffsetTop(eid1) - GXEntityCollisionOffsetBottom(eid1) - 1, _
            GXEntityX(eid2) + GXEntityCollisionOffsetLeft(eid2), _
            GXEntityY(eid2) + GXEntityCollisionOffsetTop(eid2), _
            GXEntityWidth(eid2) - GXEntityCollisionOffsetLeft(eid2) - GXEntityCollisionOffsetRight(eid2) - 1, _
            GXEntityHeight(eid2) - GXEntityCollisionOffsetTop(eid2) - GXEntityCollisionOffsetBottom(eid2) - 1)
    END FUNCTION

    FUNCTION __GX_RectCollide% (r1x1%, r1y1%, r1w%, r1h%, r2x1%, r2y1%, r2w%, r2h%)

        DIM r1x2%, r1y2%, r2x2%, r2y2%
        r1x2% = r1x1% + r1w%
        r1y2% = r1y1% + r1h%
        r2x2% = r2x1% + r2w%
        r2y2% = r2y1% + r2h%

        __GX_RectCollide = GX_FALSE
        IF r1x2% >= r2x1% THEN
            IF r1x1% <= r2x2% THEN
                IF r1y2% >= r2y1% THEN
                    IF r1y1% <= r2y2% THEN
                        __GX_RectCollide = GX_TRUE
                    END IF
                END IF
            END IF
        END IF

    END FUNCTION

    SUB __GX_FontMapChars (fid AS LONG, charref AS STRING)
        DIM cx AS INTEGER, cy AS INTEGER, i AS INTEGER, a AS INTEGER
        cx = 1
        cy = 1
        FOR i = 1 TO LEN(charref)
            a = ASC(MID$(charref, i, 1))
            IF a = 10 THEN
                cx = 1
                cy = cy + 1
            ELSE
                IF a >= 33 AND a <= 256 THEN
                    __gx_font_charmap(a, fid).x = cx
                    __gx_font_charmap(a, fid).y = cy
                END IF
                cx = cx + 1
            END IF
        NEXT i
    END SUB

    SUB __GX_FontCreateDefault (fid AS LONG)
        DIM filename AS STRING
        IF fid = GXFONT_DEFAULT_BLACK THEN
            __gx_font_default_black
            filename = "tmp/__gx_font_default_black.png"
        ELSE
            __gx_font_default
            filename = "tmp/__gx_font_default.png"
        END IF

        __gx_fonts(fid).eid = GXEntityCreate(filename, 6, 8, 1)
        KILL filename
        GXEntityVisible __gx_fonts(fid).eid, GX_FALSE
        __GX_FontMapChars fid, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~`!@#$%^&*()_-+={}[]|\,./<>?:;" + CHR$(34) + "'"
        GXFontLineSpacing fid, 1
    END SUB


    FUNCTION __GX_EntityTestMove% (entity AS INTEGER, mx AS LONG, my AS LONG, tpos AS GXPosition, collisionEntity AS INTEGER)
        tpos.x = -1
        tpos.y = -1

        DIM tcount AS INTEGER
        REDIM tiles(0) AS GXPosition
        __GX_EntityCollisionTiles entity, mx, my, tiles(), tcount


        DIM move AS INTEGER
        move = GX_TRUE

        ' Test for tile collision
        DIM i AS INTEGER, j AS INTEGER
        DIM tile AS INTEGER
        FOR i = 0 TO tcount - 1
            DIM e AS GXEvent
            e.entity = entity
            e.event = GXEVENT_COLLISION_TILE
            e.collisionTileX = tiles(i).x
            e.collisionTileY = tiles(i).y
            GXOnGameEvent e
            IF e.collisionResult THEN
                move = GX_FALSE
                tpos = tiles(i)
            END IF
        NEXT i

        ' Test for entity collision
        DIM entities(0) AS INTEGER
        DIM ecount AS INTEGER
        ecount = __GX_EntityCollision(entity, mx, my, entities())
        FOR i = 1 TO ecount
            DIM ee AS GXEvent
            ee.entity = entity
            ee.event = GXEVENT_COLLISION_ENTITY
            ee.collisionEntity = entities(i)
            GXOnGameEvent ee
            IF ee.collisionResult THEN
                move = GX_FALSE
                collisionEntity = entities(i)
            END IF
        NEXT i

        __GX_EntityTestMove = move
    END FUNCTION

    FUNCTION __GX_EntityCollision% (eid AS INTEGER, movex AS INTEGER, movey AS INTEGER, entities() AS INTEGER) ', ecount AS INTEGER)
        DIM ecount AS INTEGER
        ecount = 0

        DIM i AS INTEGER
        FOR i = 1 TO __gx_entity_count
            IF i <> eid THEN
                ' TODO: only include entities that should be considered (e.g. visible, non-screen-level)
                IF __GX_RectCollide(GXEntityX(eid) + GXEntityCollisionOffsetLeft(eid) + movex, _
                GXEntityY(eid) + GXEntityCollisionOffsetTop(eid) + movey, _
                GXEntityWidth(eid) - GXEntityCollisionOffsetLeft(eid) - GXEntityCollisionOffsetRight(eid) - 1, _
                GXEntityHeight(eid) - GXEntityCollisionOffsetTop(eid) - GXEntityCollisionOffsetBottom(eid) - 1, _
                GXEntityX(i) + GXEntityCollisionOffsetLeft(i), _
                GXEntityY(i) + GXEntityCollisionOffsetTop(i), _
                GXEntityWidth(i) - GXEntityCollisionOffsetLeft(i) - GXEntityCollisionOffsetRight(i) - 1, _
                GXEntityHeight(i) - GXEntityCollisionOffsetTop(i) - GXEntityCollisionOffsetBottom(i)-1) THEN
                    ecount = ecount + 1
                    REDIM _PRESERVE entities(ecount) AS INTEGER
                    entities(ecount) = i
                END IF
            END IF
        NEXT i

        __GX_EntityCollision = ecount
    END FUNCTION

    SUB __GX_EntityCollisionTiles (entity AS INTEGER, movex AS INTEGER, movey AS INTEGER, tiles() AS GXPosition, tcount AS INTEGER)
        DIM tx AS INTEGER, ty AS INTEGER
        DIM tx0 AS INTEGER, txn AS INTEGER
        DIM ty0 AS INTEGER, tyn AS INTEGER
        DIM x AS INTEGER, y AS INTEGER, i AS INTEGER

        IF movex <> 0 THEN
            DIM startx AS INTEGER
            startx = -1 + GXEntityCollisionOffsetLeft(entity) 'cx
            IF movex > 0 THEN startx = GXEntityWidth(entity) + movex - GXEntityCollisionOffsetRight(entity) 'cx2
            tx = FIX((GXEntityX(entity) + startx) / GXTilesetWidth)

            ' This is a real brute force way to find the intersecting tiles.
            ' We're basically testing every pixel along the edge of the entity's
            ' collision rect and incrementing the collision tile count.
            ' With a bit more math I'm sure we could avoid some extra loops here.
            tcount = 0
            ty0 = 0
            FOR y = GXEntityY(entity) + GXEntityCollisionOffsetTop(entity) TO GXEntityY(entity) + GXEntityHeight(entity) - 1 - GXEntityCollisionOffsetBottom(entity)
                ty = FIX(y / GXTilesetHeight)
                IF tcount = 0 THEN ty0 = ty
                IF NOT ty = tyn THEN
                    tcount = tcount + 1
                END IF
                tyn = ty
            NEXT y

            ' Add the range of detected tile positions to the return list
            REDIM tiles(tcount) AS GXPosition
            i = 0
            FOR ty = ty0 TO tyn
                tiles(i).x = tx
                tiles(i).y = ty
                i = i + 1
            NEXT ty
        END IF

        IF movey <> 0 THEN
            DIM starty AS INTEGER
            starty = -1 + GXEntityCollisionOffsetTop(entity) 'cy
            IF movey > 0 THEN starty = GXEntityHeight(entity) + movey - GXEntityCollisionOffsetBottom(entity) 'cy2
            ty = FIX((GXEntityY(entity) + starty) / GXTilesetHeight)

            ' This is a real brute force way to find the intersecting tiles.
            ' We're basically testing every pixel along the edge of the entity's
            ' collision rect and incrementing the collision tile count.
            ' With a bit more math I'm sure we could avoid some extra loops here.
            tcount = 0
            tx0 = 0
            FOR x = GXEntityX(entity) + GXEntityCollisionOffsetLeft(entity) TO GXEntityX(entity) + GXEntityWidth(entity) - 1 - GXEntityCollisionOffsetRight(entity)
                tx = FIX(x / GXTilesetWidth)
                IF tcount = 0 THEN tx0 = tx
                IF NOT tx = txn THEN
                    tcount = tcount + 1
                END IF
                txn = tx
            NEXT x

            REDIM tiles(tcount) AS GXPosition
            i = 0
            FOR tx = tx0 TO txn
                tiles(i).x = tx
                tiles(i).y = ty
                i = i + 1
            NEXT tx
        END IF
    END SUB

    SUB GXKeyInput (k AS LONG, di AS GXDeviceInput)
        di.deviceId = 1
        di.deviceType = GXDEVICE_KEYBOARD
        di.inputType = GXDEVICE_BUTTON
        di.inputId = k
        di.inputValue = -1
    END SUB

    FUNCTION GXKeyDown% (k AS LONG)
        DIM di AS GXDeviceInput
        GXKeyInput k, di
        GXKeyDown = GXDeviceInputTest(di)
    END FUNCTION


    SUB GXDeviceInputDetect (di AS GXDeviceInput)
        DIM found AS INTEGER
        DIM dcount AS INTEGER
        dcount = _DEVICES

        WHILE _DEVICEINPUT
            ' Flush the input buffer
        WEND

        DO
            _LIMIT 90
            DIM x AS INTEGER
            x = _DEVICEINPUT
            IF x THEN
                DIM i AS INTEGER
                FOR i = 1 TO _LASTBUTTON(x)
                    IF _BUTTON(i) THEN
                        di.deviceId = x
                        di.deviceType = __GX_DeviceTypeName(x)
                        di.inputType = GXDEVICE_BUTTON
                        di.inputId = i
                        di.inputValue = _BUTTON(i)
                        found = 1
                        EXIT DO
                    END IF
                NEXT i

                FOR i = 1 TO _LASTAXIS(x)
                    IF _AXIS(i) AND ABS(_AXIS(i)) = 1 THEN
                        di.deviceId = x
                        di.deviceType = __GX_DeviceTypeName(x)
                        di.inputType = GXDEVICE_AXIS
                        di.inputId = i
                        di.inputValue = _AXIS(i)
                        found = 1
                        EXIT DO
                    END IF
                NEXT i

                FOR i = 1 TO _LASTWHEEL(x)
                    IF _WHEEL(i) THEN
                        di.deviceId = x
                        di.deviceType = __GX_DeviceTypeName(x)
                        di.inputType = GXDEVICE_WHEEL
                        di.inputId = i
                        di.inputValue = _WHEEL(i)
                        found = 1
                        EXIT DO
                    END IF
                NEXT i
            END IF

            $IF LINUX OR MAC THEN
                ' No device input found, as a workaround let's loop through the key map looking for a keydown
                For i = UBound(__gx_keymap) To 1 Step -1
                    Dim keyIsDown As Integer, inputId As Integer
                    keyIsDown = GX_FALSE
                    If __gx_keymap(i).value <> 0 Then
                        'If i > 29 Then
                        '    Print i; __gx_keymap(i).value
                        '    Dim x: Input x
                        'End If
                        If _KeyDown(__gx_keymap(i).value) Then
                            keyIsDown = GX_TRUE
                            inputId = i
                        ElseIf __gx_keymap(i).shift <> 0 Then
                            If _KeyDown(__gx_keymap(i).shift) Then
                                keyIsDown = GX_TRUE
                                inputId = i
                            End If
                        End If
                    End If
                    If keyIsDown Then
                        di.deviceId = GXDEVICE_KEYBOARD
                        di.deviceType = __GX_DeviceTypeName(GXDEVICE_KEYBOARD)
                        di.inputType = GXDEVICE_BUTTON
                        di.inputId = inputId
                        di.inputValue = GX_TRUE
                        found = 1
                        Exit Do
                    End If
                Next i
            $END IF
        LOOP UNTIL found

        WHILE _DEVICEINPUT
            '    Flush the device input buffer
        WEND
        _KEYCLEAR

    END SUB

    FUNCTION __GX_DeviceTypeName% (deviceId)
        DIM dname AS STRING
        dname = _DEVICE$(deviceId)

        IF INSTR(dname, "[KEYBOARD]") THEN
            __GX_DeviceTypeName = GXDEVICE_KEYBOARD
        ELSEIF INSTR(dname, "[MOUSE]") THEN
            __GX_DeviceTypeName = GXDEVICE_MOUSE
        ELSEIF INSTR(dname, "[CONTROLLER]") THEN
            __GX_DeviceTypeName = GXDEVICE_CONTROLLER
        END IF
    END FUNCTION

    FUNCTION GXDeviceName$ (deviceId AS INTEGER)
        DIM nstart AS INTEGER, nend AS INTEGER
        DIM dname AS STRING
        dname = _DEVICE$(deviceId)
        IF INSTR(dname, "[CONTROLLER]") THEN
            nstart = INSTR(dname, "[NAME]")
            IF nstart = 0 THEN
                dname = "Controller"
            ELSE
                nstart = nstart + 7
                nend = INSTR(nstart, dname, "]]")
                dname = _TRIM$(MID$(dname, nstart, nend - nstart))
            END IF
        ELSEIF INSTR(dname, "[MOUSE]") THEN
            dname = "Mouse"
        ELSEIF INSTR(dname, "[KEYBOARD]") THEN
            dname = "Keyboard"
        END IF
        GXDeviceName = dname
    END FUNCTION

    FUNCTION GXDeviceTypeName$ (dtype AS INTEGER)
        DIM dtypename AS STRING
        SELECT CASE dtype
            CASE GXDEVICE_KEYBOARD: dtypename = "KEYBOARD"
            CASE GXDEVICE_MOUSE: dtypename = "MOUSE"
            CASE GXDEVICE_CONTROLLER: dtypename = "CONTROLLER"
        END SELECT
        GXDeviceTypeName = dtypename
    END FUNCTION

    FUNCTION GXInputTypeName$ (itype AS INTEGER)
        DIM itypename AS STRING
        SELECT CASE itype
            CASE GXDEVICE_BUTTON: itypename = "BUTTON"
            CASE GXDEVICE_AXIS: itypename = "AXIS"
            CASE GXDEVICE_WHEEL: itypename = "WHEEL"
        END SELECT
        GXInputTypeName = itypename
    END FUNCTION

    FUNCTION GXKeyButtonName$ (inputId AS INTEGER)
        DIM k AS STRING
        SELECT CASE inputId
            CASE GXKEY_ESC: k = "Esc"
            CASE GXKEY_1: k = "1"
            CASE GXKEY_2: k = "2"
            CASE GXKEY_3: k = "3"
            CASE GXKEY_4: k = "4"
            CASE GXKEY_5: k = "5"
            CASE GXKEY_6: k = "6"
            CASE GXKEY_7: k = "7"
            CASE GXKEY_8: k = "8"
            CASE GXKEY_9: k = "9"
            CASE GXKEY_0: k = "0"
            CASE GXKEY_DASH: k = "-"
            CASE GXKEY_EQUALS: k = "="
            CASE GXKEY_BACKSPACE: k = "Bksp"
            CASE GXKEY_TAB: k = "Tab"
            CASE GXKEY_Q: k = "Q"
            CASE GXKEY_W: k = "W"
            CASE GXKEY_E: k = "E"
            CASE GXKEY_R: k = "R"
            CASE GXKEY_T: k = "T"
            CASE GXKEY_Y: k = "Y"
            CASE GXKEY_U: k = "U"
            CASE GXKEY_I: k = "I"
            CASE GXKEY_O: k = "O"
            CASE GXKEY_P: k = "P"
            CASE GXKEY_LBRACKET: k = "["
            CASE GXKEY_RBRACKET: k = "]"
            CASE GXKEY_ENTER: k = "Enter"
            CASE GXKEY_LCTRL: k = "LCtrl"
            CASE GXKEY_A: k = "A"
            CASE GXKEY_S: k = "S"
            CASE GXKEY_D: k = "D"
            CASE GXKEY_F: k = "F"
            CASE GXKEY_G: k = "G"
            CASE GXKEY_H: k = "H"
            CASE GXKEY_J: k = "J"
            CASE GXKEY_K: k = "K"
            CASE GXKEY_L: k = "L"
            CASE GXKEY_SEMICOLON: k = ";"
            CASE GXKEY_QUOTE: k = "'"
            CASE GXKEY_BACKQUOTE: k = "`"
            CASE GXKEY_LSHIFT: k = "LShift"
            CASE GXKEY_BACKSLASH: k = "\"
            CASE GXKEY_Z: k = "Z"
            CASE GXKEY_X: k = "X"
            CASE GXKEY_C: k = "C"
            CASE GXKEY_V: k = "V"
            CASE GXKEY_B: k = "B"
            CASE GXKEY_N: k = "N"
            CASE GXKEY_M: k = "M"
            CASE GXKEY_COMMA: k = ","
            CASE GXKEY_PERIOD: k = "."
            CASE GXKEY_SLASH: k = "/"
            CASE GXKEY_RSHIFT: k = "RShift"
            CASE GXKEY_NUMPAD_MULTIPLY: k = "NPad *"
            CASE GXKEY_SPACEBAR: k = "Space"
            CASE GXKEY_CAPSLOCK: k = "CapsLk"
            CASE GXKEY_F1: k = "F1"
            CASE GXKEY_F2: k = "F2"
            CASE GXKEY_F3: k = "F3"
            CASE GXKEY_F4: k = "F4"
            CASE GXKEY_F5: k = "F5"
            CASE GXKEY_F6: k = "F6"
            CASE GXKEY_F7: k = "F7"
            CASE GXKEY_F8: k = "F8"
            CASE GXKEY_F9: k = "F9"
            CASE GXKEY_PAUSE: k = "Pause"
            CASE GXKEY_SCRLK: k = "ScrLk"
            CASE GXKEY_NUMPAD_7: k = "NPad 7"
            CASE GXKEY_NUMPAD_8: k = "NPad 8"
            CASE GXKEY_NUMPAD_9: k = "NPad 9"
            CASE GXKEY_NUMPAD_MINUS: k = "-"
            CASE GXKEY_NUMPAD_4: k = "NPad 4"
            CASE GXKEY_NUMPAD_5: k = "NPad 5"
            CASE GXKEY_NUMPAD_6: k = "NPad 6"
            CASE GXKEY_NUMPAD_PLUS: k = "+"
            CASE GXKEY_NUMPAD_1: k = "NPad 1"
            CASE GXKEY_NUMPAD_2: k = "NPad 2"
            CASE GXKEY_NUMPAD_3: k = "NPad 3"
            CASE GXKEY_NUMPAD_0: k = "NPad 0"
            CASE GXKEY_NUMPAD_PERIOD: k = "NPad ."
            CASE GXKEY_F11: k = "F11"
            CASE GXKEY_F12: k = "F12"
            CASE GXKEY_NUMPAD_ENTER: k = "NPad Enter"
            CASE GXKEY_RCTRL: k = "RCtrl"
            CASE GXKEY_NUMPAD_DIVIDE: k = "NPad /"
            CASE GXKEY_NUMLOCK: k = "NumLk"
            CASE GXKEY_HOME: k = "Home"
            CASE GXKEY_UP: k = "Up"
            CASE GXKEY_PAGEUP: k = "PgUp"
            CASE GXKEY_LEFT: k = "Left"
            CASE GXKEY_RIGHT: k = "Right"
            CASE GXKEY_END: k = "End"
            CASE GXKEY_DOWN: k = "Down"
            CASE GXKEY_PAGEDOWN: k = "PgDn"
            CASE GXKEY_INSERT: k = "Ins"
            CASE GXKEY_DELETE: k = "Del"
            CASE GXKEY_LWIN: k = "LWin"
            CASE GXKEY_RWIN: k = "RWin"
            CASE GXKEY_MENU: k = "Menu"
        END SELECT
        GXKeyButtonName = k
    END FUNCTION

    '$INCLUDE: 'gx_fs.bm'
    '$INCLUDE: 'resource/font-default.png.bm'
    '$INCLUDE: 'resource/font-default-black.png.bm'

    $LET GXBM = 1
$END IF
